<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JDBC</title>
      <link href="/2024/05/17/JDBC/"/>
      <url>/2024/05/17/JDBC/</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="一、JDBC快速入门"><a href="#一、JDBC快速入门" class="headerlink" title="一、JDBC快速入门"></a>一、JDBC快速入门</h2><ol><li><p>注册驱动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、注册驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>自动注册驱动：在 JDBC 4.0 及更高版本中，驱动程序 jar 包中的 META-INF&#x2F;services&#x2F;java.sql.Driver 文件会自动注册驱动程序。<br>所以在mysql 5之后的驱动包，可以省略注册驱动的步骤。</p></blockquote></li><li><p>获取连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.获取连接</span></span><br><span class="line">String url=<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/testjdbc&quot;</span>;</span><br><span class="line">String username=<span class="string">&quot;root&quot;</span>;</span><br><span class="line">String password=<span class="string">&quot;24211&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br></pre></td></tr></table></figure></li><li><p>定义SQL语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.定义SQL语句</span></span><br><span class="line">String sql=<span class="string">&quot;update user set money=2000 where id=1&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>获取执行sql的对象Statement</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//4.获取执行sql的对象Statement</span></span><br><span class="line">Statement statement=connection.createStatement();</span><br></pre></td></tr></table></figure><p>5.执行sql</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">executed</span> <span class="operator">=</span> statement.executeUpdate(sql);  <span class="comment">//返回受影响的行数。</span></span><br><span class="line">System.out.println(executed);</span><br></pre></td></tr></table></figure></li><li><p>释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6.释放资源</span></span><br><span class="line">statement.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure><blockquote><p>注意，释放顺序不能打乱。</p></blockquote></li></ol><h2 id="二、JDBC-API详解"><a href="#二、JDBC-API详解" class="headerlink" title="二、JDBC API详解"></a>二、JDBC API详解</h2><h3 id="2-1-DriverManager"><a href="#2-1-DriverManager" class="headerlink" title="2.1 DriverManager"></a>2.1 DriverManager</h3><ol><li>注册驱动程序</li><li>获取数据库连接</li></ol><h4 id="1-注册驱动程序"><a href="#1-注册驱动程序" class="headerlink" title="1. 注册驱动程序"></a>1. 注册驱动程序</h4><p>当你加载数据库驱动程序类时，它会自动向 <code>DriverManager</code> 注册自己。通常，通过 <code>Class.forName</code> 方法加载驱动程序类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Driver源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">extends</span> <span class="title class_">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title class_">java</span>.sql.Driver &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>()); <span class="comment">//真正注册驱动的代码，在类加载时自动执行。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-获取连接-DriverManager-getConnection"><a href="#2-获取连接-DriverManager-getConnection" class="headerlink" title="2. 获取连接(DriverManager.getConnection)"></a>2. 获取连接(<code>DriverManager.getConnection</code>)</h4><p><code>getConnection(String url, String user, String password)</code></p><ul><li>定义数据库连接参数<ul><li>url：指定数据库的位置和数据库名称。语法：jdbc:mysql:&#x2F;&#x2F;ip地址(域名):端口号&#x2F;数据库名称？参数键对值1&amp;参数键对值1…</li><li>user：用户名</li><li>password：密码</li></ul></li></ul><blockquote><p>如果连接的是本地mysql并且端口是默认的3306，则可以简化书写：jdbc:mysql:&#x2F;&#x2F;&#x2F;数据库名<br>useSSL 是 JDBC URL 中的一个参数，用于指定是否在客户端和数据库服务器之间使用 SSL（安全套接字层）加密。useSSL&#x3D;false不起用，useSSL&#x3D;true启用。</p></blockquote><h3 id="2-2-Connection"><a href="#2-2-Connection" class="headerlink" title="2.2  Connection"></a>2.2  Connection</h3><ol><li>获取执行SQL的对象    <ul><li>Statement用于执行静态SQL语句。   </li><li>PreparedStatement用于执行预编译的SQL语句。   </li><li>CallableStatement用于执行存储过程。</li></ul></li><li>管理事务    <ul><li><p>MySQL 中的事务管理<br>开始事务：使用 <code>START TRANSACTION</code> 或 <code>BEGIN </code>命令开始一个新的事务。<br>提交事务：使用 <code>COMMIT </code>命令将事务中的操作永久保存到数据库中。<br>回滚事务：使用 <code>ROLLBACK</code> 命令取消事务中的所有操作，并恢复到事务开始之前的状态。    </p><blockquote><p>注意：MySql默认自动提交事务。    </p></blockquote></li><li><p>JDBC 中的事务管理<br>开启事务&#x2F;关闭自动提交：使用 <code>setAutoCommit(false)</code> 方法关闭自动提交模式，从而启用事务。<br>提交事务：通过 <code>commit() </code>方法提交事务，将事务中的操作永久保存到数据库中。<br>回滚事务：如果发生错误或其他异常，可以使用 <code>rollback() </code>方法取消事务中的所有操作，并恢复到事务开始之前的状态。</p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransaction</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">String url=<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/testjdbc?useSSL=false&quot;</span>;</span><br><span class="line">String username=<span class="string">&quot;root&quot;</span>;</span><br><span class="line">String password=<span class="string">&quot;24211&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">String sql1=<span class="string">&quot;update user set money=6000 where id=1&quot;</span>;</span><br><span class="line">String sql2=<span class="string">&quot;update user set money=6000 where id=2&quot;</span>;</span><br><span class="line">Statement statement=connection.createStatement();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line">connection.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> statement.executeUpdate(sql1);  <span class="comment">//返回受影响的行数。</span></span><br><span class="line">            <span class="comment">//int i=3/0; 测试事务</span></span><br><span class="line">            count =count + statement.executeUpdate(sql2);</span><br><span class="line">            System.out.println(count);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//提交事务</span></span><br><span class="line">            connection.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">//回滚事务</span></span><br><span class="line">            connection.rollback();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUnit单元测试</title>
      <link href="/2024/05/16/JUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/2024/05/16/JUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="JUnit单元测试"><a href="#JUnit单元测试" class="headerlink" title="JUnit单元测试"></a>JUnit单元测试</h1><h3 id="1、单元测试类"><a href="#1、单元测试类" class="headerlink" title="1、单元测试类"></a>1、单元测试类</h3><p>单元测试类名：XxxTest</p><h3 id="2、单元测试方法"><a href="#2、单元测试方法" class="headerlink" title="2、单元测试方法"></a>2、单元测试方法</h3><ol><li>单元测试方法需要用<code>@Test</code>注解标注。</li><li>单元测试方法返回类型必须是<code>void</code>。</li><li>单元测试方法形参个数为0.</li><li>单元测试方法名约定规范为：testXxx。</li><li>在JUnit5中，方法名可以不用声明为public。</li></ol><h3 id="3、期望值、实际值"><a href="#3、期望值、实际值" class="headerlink" title="3、期望值、实际值"></a>3、期望值、实际值</h3><p><strong>期望值（Expected Value）：</strong><br>期望值是指在执行单元测试时，开发者预期被测试代码会产生的结果。<br>在编写单元测试时，通常会先确定要测试的功能或情况，并明确预期的输出、状态或行为。<br>期望值可以是一个具体的数值、对象、状态等，取决于正在测试的功能。在测试方法中，开发者会使用断言方法来验证实际结果是否与期望值一致。<br><strong>实际值（Actual Value）：</strong><br>实际值是指被测试代码在执行单元测试时产生的实际结果。<br>实际值是通过执行被测试的代码来获取的，它反映了代码在给定输入下的真实行为。<br>在单元测试方法中，开发者会调用被测试的方法或功能，并获取其输出、状态或行为，然后与期望值进行比较。    </p><h3 id="4、常见注解"><a href="#4、常见注解" class="headerlink" title="4、常见注解"></a>4、常见注解</h3><p><code>@BeforeAll</code>、<code>@AfterAll</code>、<code>@BeforeEach</code> 和 <code>@AfterEach</code> 是JUnit 5中用于执行测试前后操作的生命周期方法。它们提供了一种方便的方式来执行一些公共的初始化和清理工作，以确保测试的独立性和可重复性。</p><ol><li><p><strong>@BeforeAll</strong>：</p><ul><li><code>@BeforeAll</code> 注解用于指定在运行测试类中的<strong>所有测试方法之前</strong>执行的方法。</li><li>该注解标记的方法必须是<strong>静态的</strong>，且必须返回<code>void</code>。</li><li>通常用于执行一次性的全局初始化工作，例如创建数据库连接、启动服务器等。</li><li>在一个测试类中，<code>@BeforeAll</code> 注解标记的方法只会执行一次，并且在所有测试方法之前执行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始执行单元测试了！&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>@AfterAll</strong>：</p><ul><li><code>@AfterAll</code> 注解用于指定在运行测试类中的<strong>所有测试方法之后</strong>执行的方法。</li><li>该注解标记的方法必须是<strong>静态的</strong>，且必须返回<code>void</code>。</li><li>通常用于执行一次性的全局清理工作，例如关闭数据库连接、停止服务器等。</li><li>在一个测试类中，<code>@AfterAll</code> 注解标记的方法只会执行一次，并且在所有测试方法之后执行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterAll</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;单元测试执行完毕！&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>@BeforeEach</strong>：</p><ul><li><code>@BeforeEach</code> 注解用于指定在运行<strong>每个测试方法之前</strong>执行的方法。</li><li>该注解标记的方法<strong>不需</strong>要是静态的，但必须返回<code>void</code>。</li><li>通常用于执行每个测试方法之前的初始化工作，例如创建临时对象、设置测试数据等。</li><li>在一个测试类中，每个<code>@BeforeEach</code> 注解标记的方法都会在对应的测试方法之前执行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeEach</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;单元测试方法开始执行&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>@AfterEach</strong>：</p><ul><li><code>@AfterEach</code> 注解用于指定在运行<strong>每个测试方法之后</strong>执行的方法。</li><li>该注解标记的方法<strong>不需</strong>要是静态的，但必须返回<code>void</code>。</li><li>通常用于执行每个测试方法之后的清理工作，例如释放资源、恢复状态等。</li><li>在一个测试类中，每个<code>@AfterEach</code> 注解标记的方法都会在对应的测试方法之后执行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterEach</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;单元测试方法执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="5、单元测试断言"><a href="#5、单元测试断言" class="headerlink" title="5、单元测试断言"></a>5、单元测试断言</h3><p>在单元测试中，断言是一种用于验证代码行为的机制。<br>它允许开发者在测试代码中声明预期结果，并与实际结果进行比较，从而验证代码是否按预期工作。<br>如果预期结果与实际结果相符，则断言通过，否则测试失败。    </p><p>在JUnit中，常用的断言方法包括：</p><ol><li><p>**assertEquals(expected, actual)**：断言两个对象是否相等。如果预期值（expected）等于实际值（actual），则断言通过。</p></li><li><p>**assertTrue(condition)**：断言给定的条件是否为真。如果条件为真，则断言通过。</p></li><li><p>**assertFalse(condition)**：断言给定的条件是否为假。如果条件为假，则断言通过。</p></li><li><p>**assertNull(object)**：断言给定的对象是否为null。如果对象为null，则断言通过。</p></li><li><p>**assertNotNull(object)**：断言给定的对象是否不为null。如果对象不为null，则断言通过。</p></li><li><p>**assertArrayEquals(expectedArray, actualArray)**：断言两个数组是否相等。如果预期数组（expectedArray）与实际数组（actualArray）相等，则断言通过。</p></li><li><p>**assertSame(expected, actual)**：断言两个对象引用是否指向同一个对象。如果预期对象（expected）和实际对象（actual）是同一个对象，则断言通过。</p></li><li><p>**assertNotSame(expected, actual)**：断言两个对象引用是否指向不同的对象。如果预期对象（expected）和实际对象（actual）不是同一个对象，则断言通过。</p></li><li><p>**assertThrows(expectedException, executable)**：断言给定的代码块是否抛出了预期的异常。如果代码块抛出了预期的异常，则断言通过。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
          <category> Java Part_1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维数组</title>
      <link href="/2024/05/11/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
      <url>/2024/05/11/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一维数组</title>
      <link href="/2024/05/09/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
      <url>/2024/05/09/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="一、数组介绍"><a href="#一、数组介绍" class="headerlink" title="一、数组介绍"></a>一、数组介绍</h2><h2 id="二、静态一维数组"><a href="#二、静态一维数组" class="headerlink" title="二、静态一维数组"></a>二、静态一维数组</h2><h3 id="2-1、初始化静态一维数组"><a href="#2-1、初始化静态一维数组" class="headerlink" title="2.1、初始化静态一维数组"></a>2.1、初始化静态一维数组</h3><p>静态初始化一维数组是在创建数组时直接指定数组元素的值，而不是在后续的代码中逐个赋值。Java中有两种方式可以静态初始化一维数组：   </p><ol><li><p><strong>使用<code>new</code>关键字：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 变量名 = <span class="keyword">new</span> 数据类型[]&#123;元素<span class="number">1</span>, 元素<span class="number">2</span>, 元素<span class="number">3</span>, ...&#125;;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">34</span>, <span class="number">45</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>省略<code>new</code>关键字：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 变量名 = &#123;元素<span class="number">1</span>, 元素<span class="number">2</span>, 元素<span class="number">3</span>, ...&#125;;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">34</span>, <span class="number">45</span>&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>这两种方式都会在内存中创建数组对象，并为数组的每个元素赋予特定的值。通常情况下，如果在创建数组对象时就已经知道了数组中应该具体存储哪些元素，就可以使用静态初始化。   </p><h2 id="三、for-each增强for循环"><a href="#三、for-each增强for循环" class="headerlink" title="三、for each增强for循环"></a>三、for each增强for循环</h2><p>增强for循环，也被称为for-each循环，是 JDK5 中引入的一个语法糖，用于简化数组和集合的遍历操作。其语法结构如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (数据中元素的数据类型 变量名 : 数组名或集合名) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在增强for循环中，变量名代表数组或集合中的每个元素，循环会依次将数组或集合中的每个元素赋给变量名，并执行循环体中的代码块。   </p><p>增强for循环的优点在于代码简洁，可读性强，能够避免因手动控制下标而引起的错误。但是其缺点是无法直接获取数组或集合的下标，如果需要使用到下标，就需要另外的方式来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 静态初始化一维数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>&#125;;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;lucy&quot;</span>, <span class="string">&quot;tom&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历arr数组(for-each)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : arr)&#123;</span><br><span class="line">            <span class="comment">// num代表数组中的每个元素</span></span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历names数组(for-each)</span></span><br><span class="line">        <span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、一维数组动态初始化"><a href="#四、一维数组动态初始化" class="headerlink" title="四、一维数组动态初始化"></a>四、一维数组动态初始化</h2><p>动态初始化一维数组是指在创建数组时只指定数组的长度，而不指定数组元素的具体值。Java 中动态初始化一维数组的语法如下：   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[数组长度];</span><br></pre></td></tr></table></figure><p>其中，<code>数据类型</code> 表示数组中元素的数据类型，<code>数组名</code> 是数组的标识符，<code>数组长度</code> 是数组中元素的个数。</p><p>例如，要创建一个长度为 5 的整型数组，可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>这样就创建了一个名为 <code>numbers</code> 的整型数组，它有 5 个元素，但这些元素的值在创建时并未指定，它们会被自动初始化为默认值（对于基本数据类型的数组，例如 <code>int</code>，默认值为 0）。</p><blockquote><p>动态初始化一维数组常用于在后续的代码中根据需要动态设置数组元素的值。</p></blockquote><h2 id="五、方法参数是一维数组时如何传参？"><a href="#五、方法参数是一维数组时如何传参？" class="headerlink" title="五、方法参数是一维数组时如何传参？"></a>五、方法参数是一维数组时如何传参？</h2><p>在 Java 中，当一个方法的参数是一个数组时，可以通过以下方式传递参数：</p><ol><li><p><strong>创建好数组对象，然后将数组对象作为参数传递：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">display(nums);</span><br></pre></td></tr></table></figure></li><li><p><strong>直接传递数组对象的初始化表达式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>动态初始化数组，并将数组对象作为参数传递：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>]);</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 第一种方式（静态初始化）：创建好数组对象，然后传进去</span></span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        display(nums);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二种方式（静态初始化）：直接传</span></span><br><span class="line">        <span class="comment">//display(&#123;1,2,3,4&#125;); // 这是错误的。</span></span><br><span class="line">        display(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;); <span class="comment">// 这是正确的。注意这个小细节。</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态初始化方式。</span></span><br><span class="line">        display(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历一维数组。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : arr) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、-引用类型一维数组（-多态）"><a href="#六、-引用类型一维数组（-多态）" class="headerlink" title="六、 *  引用类型一维数组（+多态）"></a>六、 *  引用类型一维数组（+多态）<img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/asserts_JavaSE/202405091705650.png"></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.array1.oop1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.array1.oop1;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bird类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸟儿在飞翔！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.array1.oop1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cat类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫抓老鼠！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.array1.oop1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Bird</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个数组，让该数组既可以存储Cat，又可以存储Bird</span></span><br><span class="line">        <span class="comment">// 数组中存储的不是对象本身，实际上是对象在堆内存中的地址。存储的是引用。</span></span><br><span class="line">        Animal[] animals = &#123;b, c, <span class="keyword">new</span> <span class="title class_">Cat</span>(), <span class="keyword">new</span> <span class="title class_">Bird</span>()&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请遍历Animal数组，然后取出的Cat让它抓老鼠，取出的Bird让它飞。</span></span><br><span class="line">        <span class="keyword">for</span> (Animal animal : animals) &#123;</span><br><span class="line">            <span class="comment">// 向下转型。</span></span><br><span class="line">            <span class="keyword">if</span>(animal <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">                <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) animal;</span><br><span class="line">                cat.catchMouse();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(animal <span class="keyword">instanceof</span> Bird) &#123;</span><br><span class="line">                <span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> (Bird) animal;</span><br><span class="line">                bird.fly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Bird bird = new Bird();</span></span><br><span class="line"><span class="comment">//        编译报错。类型不统一/不一致。</span></span><br><span class="line"><span class="comment">//        Cat[] cats = &#123;c, bird&#125;;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="七、关于main方法的命令行参数"><a href="#七、关于main方法的命令行参数" class="headerlink" title="七、关于main方法的命令行参数"></a>七、关于main方法的命令行参数</h2><p>在 Java 中，<code>public static void main(String[] args)</code> 方法是 Java 应用程序的入口点，它是程序执行的起点。在 <code>main</code> 方法中的 <code>String[] args</code> 参数用于接收命令行参数。</p><p>命令行参数是在运行 Java 程序时通过命令行输入的参数，它们可以是任意数量的字符串值，用空格分隔。这些参数被传递给 <code>main</code> 方法的 <code>args</code> 参数，<code>args</code> 是一个字符串数组，其中每个元素对应一个命令行参数。</p><p>例如，假设你有一个名为 <code>MyProgram</code> 的 Java 程序，并且在命令行中运行它时提供了一些参数，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java MyProgram arg1 arg2 arg3</span><br></pre></td></tr></table></figure><p>在这种情况下，<code>main</code> 方法的 <code>args</code> 参数将包含一个长度为 3 的字符串数组，其中 <code>args[0]</code> 是 <code>&quot;arg1&quot;</code>，<code>args[1]</code> 是 <code>&quot;arg2&quot;</code>，<code>args[2]</code> 是 <code>&quot;arg3&quot;</code>。</p><p>因此，<code>String[] args</code> 参数使得 Java 程序能够接收和处理来自命令行的参数，这样程序可以根据需要执行不同的操作或使用不同的设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 需求：使用该系统的用户包括两种</span></span><br><span class="line">        <span class="comment">// 一个是普通用户</span></span><br><span class="line">        <span class="comment">// 一个是超级管理用户</span></span><br><span class="line">        <span class="comment">// 如果是超级管理员用户，在命令行参数的第一个参数上标注：admin，如果是普通用户第一个参数上标注：user</span></span><br><span class="line">        <span class="comment">// 假设超级管理员的用户名和密码是：zhangsan 123</span></span><br><span class="line">        <span class="comment">// 假设普通用户名和密码是：lisi 123</span></span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">3</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对不起，命令行参数不正确，要使用该系统，命令行参数格式必须是：java ArrayTest 角色 用户名 密码&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出角色</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">role</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 取出用户名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> args[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 取出密码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> args[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当两个字符串String进行equals的时候，并且其中有一个字符串是字面量。</span></span><br><span class="line">        <span class="comment">// 建议将字面量写到前面。可以避免空指针异常的发生。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(role) &amp;&amp; username.equals(<span class="string">&quot;zhangsan&quot;</span>) &amp;&amp; password.equals(<span class="string">&quot;123&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;欢迎超级管理员&quot;</span> + username + <span class="string">&quot;，请使用本系统！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (role.equals(<span class="string">&quot;user&quot;</span>) &amp;&amp; username.equals(<span class="string">&quot;lisi&quot;</span>) &amp;&amp; password.equals(<span class="string">&quot;123&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;欢迎操作员&quot;</span> + username + <span class="string">&quot;，请使用本系统！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;角色不对，或者用户名不存在，可能密码也错了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当两个字符串String进行equals的时候，并且其中有一个字符串是字面量,建议将字面量写到前面。可以避免空指针异常发生。</p></blockquote><h2 id="八、关于方法的可变长度参数"><a href="#八、关于方法的可变长度参数" class="headerlink" title="八、关于方法的可变长度参数"></a>八、关于方法的可变长度参数</h2><p>在 Java 中，可变长度参数的语法规则如下：</p><ol><li><p><strong>语法格式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回类型 方法名(数据类型... 参数名) &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>省略号（<code>...</code>）</strong>：</p><ul><li>在方法声明中，省略号（<code>...</code>）用于指示可变长度参数的位置。</li><li>省略号必须放在参数类型之后，并且只能出现在参数列表的最后一个位置。</li></ul></li><li><p><strong>参数类型</strong>：</p><ul><li>可变长度参数可以是任意数据类型，包括基本数据类型和引用数据类型。</li></ul></li><li><p><strong>传递参数</strong>：</p><ul><li>在调用方法时，你可以传递任意数量的参数给可变长度参数。</li><li>这些参数将被封装成一个数组传递给方法内部。</li></ul></li><li><p><strong>数组访问</strong>：</p><ul><li>在方法内部，可变长度参数被视为一个数组。</li><li>你可以像操作数组一样操作可变长度参数，例如使用循环遍历、获取长度等。</li></ul></li><li><p><strong>与其他参数共存</strong>：</p><ul><li>可变长度参数可以与其他类型的参数一起使用，但是可变长度参数必须是参数列表的最后一个参数。</li></ul></li><li><p><strong>只能有一个可变长度参数</strong>：</p><ul><li>每个方法最多只能有一个可变长度参数。</li></ul></li></ol><ul><li>下面是一个简单的示例，展示了如何在方法中使用可变长度参数：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VarargsExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用可变长度参数来计算多个数的和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>... numbers)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">            total += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用方法时可以传递任意数量的参数</span></span><br><span class="line">        System.out.println(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));        <span class="comment">// 输出：6</span></span><br><span class="line">        System.out.println(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));  <span class="comment">// 输出：15</span></span><br><span class="line">        System.out.println(sum(<span class="number">10</span>));             <span class="comment">// 输出：10</span></span><br><span class="line">        System.out.println(sum());               <span class="comment">// 输出：0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>sum</code> 方法接受可变长度参数 <code>numbers</code>，并计算这些参数的总和。在 <code>main</code> 方法中，我们展示了如何调用 <code>sum</code> 方法并传递不同数量的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        m5(<span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m5</span><span class="params">(Object... objs)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj : objs)&#123;</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、一维数组扩容"><a href="#九、一维数组扩容" class="headerlink" title="九、一维数组扩容"></a>九、一维数组扩容</h2><h3 id="9-1、System-arraycopy"><a href="#9-1、System-arraycopy" class="headerlink" title="9.1、System.arraycopy()"></a>9.1、System.arraycopy()</h3><p><code>System.arraycopy()</code> 方法用于将数组中指定范围的元素复制到另一个数组中的指定位置。它的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src, <span class="type">int</span> srcPos, Object dest, <span class="type">int</span> destPos, <span class="type">int</span> length)</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>src</code>：源数组，即要复制的数组。</li><li><code>srcPos</code>：源数组中的起始位置。</li><li><code>dest</code>：目标数组，即要将元素复制到的数组。</li><li><code>destPos</code>：目标数组中的起始位置。</li><li><code>length</code>：要复制的元素数量。</li></ul><h3 id="9-2、实现一维数组扩容"><a href="#9-2、实现一维数组扩容" class="headerlink" title="9.2、实现一维数组扩容"></a>9.2、实现一维数组扩容</h3><p>一维数组扩容通常指的是在已有数组基础上增加额外的存储空间以容纳更多元素。在 Java 中，数组的长度一旦确定后就无法改变，但可以通过创建一个新的更大长度的数组，然后将原数组中的元素复制到新数组中来实现数组扩容的效果。</p><p>以下是一种常见的扩容方法：</p><ol><li><p><strong>创建新数组</strong>：创建一个新的数组，长度比原数组大一些，用于存储扩容后的元素。</p></li><li><p><strong>复制元素</strong>：将原数组中的所有元素复制到新数组中，通常使用 <code>System.arraycopy()</code> 方法或者循环遍历实现。</p></li><li><p><strong>更新引用</strong>：将原数组的引用指向新数组，这样原数组就被“扩容”了。</p></li></ol><p>Java 中的 <code>ArrayList</code> 就是通过这种方式来实现动态扩容的。当元素数量达到当前数组容量时，<code>ArrayList</code> 会创建一个新的更大的数组，并将原数组中的元素复制到新数组中，然后更新内部引用指向新数组。</p><p>以下是简单示例，演示了如何实现一维数组的扩容：</p><blockquote><p>怎么优化？建议减少扩容次数。建议预测数据量，创建一个容量差不多的数组。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayExpansion</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] oldArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newSize</span> <span class="operator">=</span> oldArray.length * <span class="number">2</span>; <span class="comment">// 扩容为原数组长度的两倍</span></span><br><span class="line">        <span class="type">int</span>[] newArray = expandArray(oldArray, newSize);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;扩容后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : newArray) &#123;</span><br><span class="line">            System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] expandArray(<span class="type">int</span>[] oldArray, <span class="type">int</span> newSize) &#123;</span><br><span class="line">      <span class="type">int</span>[] newArray = <span class="keyword">new</span> <span class="title class_">int</span>[newSize];</span><br><span class="line">      <span class="comment">// 复制原数组元素到新数组中</span></span><br><span class="line">      System.arraycopy(oldArray, <span class="number">0</span>, newArray, <span class="number">0</span>, oldArray.length);</span><br><span class="line">      <span class="keyword">return</span> newArray;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
          <category> Java Part_1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内部类（Inner classes）</title>
      <link href="/2024/05/09/%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88Inner-classes%EF%BC%89/"/>
      <url>/2024/05/09/%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88Inner-classes%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="一、实例内部类-成员内部类（Member-Inner-Class）："><a href="#一、实例内部类-成员内部类（Member-Inner-Class）：" class="headerlink" title="一、实例内部类&#x2F;成员内部类（Member Inner Class）："></a>一、实例内部类&#x2F;成员内部类（Member Inner Class）：</h2><ul><li>成员内部类是定义在外部类的成员位置的类，可以直接访问外部类的所有成员变量和方法，包括私有成员。</li><li>成员内部类可以使用访问控制修饰符（如public、private、protected、default）。</li><li>外部类可以访问成员内部类的所有成员，但需要先创建内部类的对象</li></ul><h5 id="当一个成员内部类（非静态内部类）被定义在外部类中时，外部类可以访问内部类的所有成员，但是需要先创建内部类的对象。下面是一个示例："><a href="#当一个成员内部类（非静态内部类）被定义在外部类中时，外部类可以访问内部类的所有成员，但是需要先创建内部类的对象。下面是一个示例：" class="headerlink" title="当一个成员内部类（非静态内部类）被定义在外部类中时，外部类可以访问内部类的所有成员，但是需要先创建内部类的对象。下面是一个示例："></a>当一个成员内部类（非静态内部类）被定义在外部类中时，外部类可以访问内部类的所有成员，但是需要先创建内部类的对象。下面是一个示例：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">outerMember</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Outer Method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">innerMember</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Inner Method&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        <span class="comment">// 创建内部类的对象</span></span><br><span class="line">        OuterClass.<span class="type">InnerClass</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 外部类可以访问内部类的所有成员</span></span><br><span class="line">        System.out.println(inner.innerMember); <span class="comment">// 输出：20</span></span><br><span class="line">        inner.innerMethod(); <span class="comment">// 输出：Inner Method</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>InnerClass</code>是一个成员内部类，它被定义在<code>OuterClass</code>中。在<code>main()</code>方法中，首先创建了外部类的实例<code>outer</code>，然后通过该实例创建了内部类的实例<code>inner</code>。接着，外部类可以通过内部类的实例<code>inner</code>访问内部类的所有成员，包括<code>innerMember</code>成员和<code>innerMethod()</code>方法。    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类的实例方法m1执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类的静态方法m2执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例内部类</span></span><br><span class="line">    <span class="comment">// 也可以使用访问权限修饰符修饰。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">x</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            System.out.println(j);</span><br><span class="line">            m1();</span><br><span class="line">            m2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClassTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">outerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        System.out.println(outerClass.i);</span><br><span class="line">        OuterClass.<span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> outerClass.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        innerClass.x();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、静态内部类（Static-Inner-Class）"><a href="#二、静态内部类（Static-Inner-Class）" class="headerlink" title="二、静态内部类（Static Inner Class）"></a>二、静态内部类（Static Inner Class）</h2><ul><li>静态内部类使用 static 关键字修饰，与外部类的实例无关，可以直接访问外部类的静态成员。</li><li>静态内部类不能直接访问外部类的非静态成员，但可以通过<strong>创建外部类的实例</strong>来访问。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类的m1静态方法执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类的m2实例方法执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="comment">// 对于静态内部类来说：访问控制权限修饰符（public、default、protected、private）在这里都可以使用。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            <span class="comment">//System.out.println(j);</span></span><br><span class="line">            m1();</span><br><span class="line">            <span class="comment">//m2();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            <span class="comment">//System.out.println(j);</span></span><br><span class="line">            m1();</span><br><span class="line">            <span class="comment">//m2();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在类中调用。内部类修饰符可以使private。</span></span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">innerClass2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        innerClass2.m3();</span><br><span class="line">        InnerClass.m4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在其他类如何调用。（注意内部类修饰符，修饰不当会导致其他类无法访问。）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClassTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建内部类对象,静态内部类new对象形式。</span></span><br><span class="line">        OuterClass.<span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>.InnerClass();</span><br><span class="line">        <span class="comment">// 调用方法（实例方法，必须创建对象。）</span></span><br><span class="line">        innerClass.m3();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用m4方法（静态方法、用类名调用。）</span></span><br><span class="line">        OuterClass.InnerClass.m4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="在Java中，静态内部类不能直接访问外部类的非静态成员，但可以通过创建外部类的实例来访问。下面是一个简单的示例："><a href="#在Java中，静态内部类不能直接访问外部类的非静态成员，但可以通过创建外部类的实例来访问。下面是一个简单的示例：" class="headerlink" title="在Java中，静态内部类不能直接访问外部类的非静态成员，但可以通过创建外部类的实例来访问。下面是一个简单的示例："></a>在Java中，静态内部类不能直接访问外部类的非静态成员，但可以通过创建外部类的实例来访问。下面是一个简单的示例：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">outerMember</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Outer Method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 静态内部类不能直接访问外部类的非静态成员</span></span><br><span class="line">            <span class="comment">// System.out.println(outerMember); // 这行代码会产生编译错误</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过创建外部类的实例来访问外部类的非静态成员</span></span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        System.out.println(outer.outerMember); <span class="comment">// 输出：10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>StaticInnerClass</code>是一个静态内部类，它不能直接访问外部类<code>OuterClass</code>的非静态成员<code>outerMember</code>，因此在<code>innerMethod()</code>方法中，如果尝试直接访问<code>outerMember</code>，会导致编译错误。但是，通过创建<code>OuterClass</code>的实例，我们可以访问外部类的非静态成员，比如在<code>main()</code>方法中，我们创建了一个<code>OuterClass</code>的实例<code>outer</code>，并且通过该实例访问了<code>outerMember</code>成员。    </p><h2 id="三、局部内部类（Local-Inner-Class）："><a href="#三、局部内部类（Local-Inner-Class）：" class="headerlink" title="三、局部内部类（Local Inner Class）："></a>三、局部内部类（Local Inner Class）：</h2><ul><li>局部内部类定义在方法或作用域内部，只能在所在的方法或作用域内使用。</li><li>结论：局部内部类能不能访问外部类的数据，取决于局部内部类所在的方法。<ul><li>如果这个方法是静态的：只能访问外部类中静态的。</li><li>如果这个方法是实例的：可以都访问。</li></ul></li><li>局部内部类可以访问外部类的成员变量和方法，但只能访问 final 或 effectively final 的局部变量（只不过从JDK8开始。这个final关键字不需要提供了。系统自动提供。）。</li><li>局部内部类不能使用访问权限修饰符修饰。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 局部变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 局部内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">            <span class="comment">// 实例方法</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">x</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(k);</span><br><span class="line">                System.out.println(f);</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// new对象，因为其生命周期所以只能在方法体中new对象。</span></span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        innerClass.x();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 局部内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">x</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(k);</span><br><span class="line">                <span class="comment">//System.out.println(f);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClassTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">outerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        outerClass.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、-匿名内部类（Anonymous-Inner-Class）："><a href="#四、-匿名内部类（Anonymous-Inner-Class）：" class="headerlink" title="四、*匿名内部类（Anonymous Inner Class）："></a>四、*匿名内部类（Anonymous Inner Class）：</h2><ul><li>匿名内部类是没有显式名称的内部类，通常用于<strong>实现接口或继承父类</strong>，并在创建对象时进行定义。</li><li>匿名内部类不能定义构造方法，但可以初始化块和成员变量。</li><li>匿名内部类可以访问外部类的成员变量和方法，以及方法内的 final 局部变量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EG1:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodWithInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用匿名内部类实现接口</span></span><br><span class="line">        <span class="type">MyInterface</span> <span class="variable">myInterface</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInterface</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interfaceMethod</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Implementation of interface method&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        myInterface.interfaceMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">interfaceMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EG2:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建电脑对象</span></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="comment">//computer.conn(new Printer());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下conn方法参数上的代码做了两件事：</span></span><br><span class="line">        <span class="comment">// 第一：完成了匿名内部类的定义。</span></span><br><span class="line">        <span class="comment">// 第二：同时实例化了一个匿名内部类的对象。</span></span><br><span class="line">        computer.conn(<span class="keyword">new</span> <span class="title class_">Usb</span>()&#123;</span><br><span class="line">            <span class="comment">// 接口的实现</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;read.....&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;write.....&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">conn</span><span class="params">(Usb usb)</span>&#123;</span><br><span class="line">        usb.read();</span><br><span class="line">        usb.write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Usb</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写一个接口的实现类。若这个实现类可能只使用一次，这时可以使用匿名内部类避免类爆炸。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Printer implements Usb &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    @Override</span></span><br><span class="line"><span class="comment">    public void read() &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;打印机开始读取数据&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    @Override</span></span><br><span class="line"><span class="comment">    public void write() &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;打印机开始打印&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
          <category> Java Part_1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StartUML破解步骤</title>
      <link href="/2024/05/06/StartUML%E7%A0%B4%E8%A7%A3%E6%AD%A5%E9%AA%A4/"/>
      <url>/2024/05/06/StartUML%E7%A0%B4%E8%A7%A3%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>首先申明，只是用于个人学习使用。</p></blockquote><ol><li><p>安装nodejs</p></li><li><p>查看nodejs是否安装成功，输入dos命令：node -v。如果输出node版本号表示nodejs安装成功。</p></li><li><p>npm更换阿里云镜像源</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> disturl http://npmmirror.com</span><br></pre></td></tr></table></figure><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry http://registry.npmmirror.com</span><br></pre></td></tr></table></figure></li><li><p>npm安装asar</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g asar</span><br></pre></td></tr></table></figure></li><li><p>查看asar版本：asar -V</p></li><li><p>在dos命令窗口中切换目录到starUML的resources目录：【注意：以管理员身份运行dos命令窗口】</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\Program Files\StarUML\resources</span><br></pre></td></tr></table></figure></li><li><p>反编译starUML：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asar extract app.asar app</span><br></pre></td></tr></table></figure></li><li><p>修改这个文件（如果没有权限修改文件，可以在其他位置新建新文件，把原文件内容拷贝到新文件中，修改。修改完成后，将新文件替换掉原文件。）：C:\Program Files\StarUML\resources\app\src\engine\license-manager.js</p><p>在该文件中搜索：setStatus(this</p><p>找到下面的：setStatus(this, false)，将false修改为true。</p><p>将UnregisteredDialog.showDialog();注释掉。</p></li><li><p>修改这个文件：C:\Program Files\StarUML\resources\app\src\app-context.js</p><p>在该文件中搜索：!this.config</p><p>将该if语句中嵌套的if语句注释掉。</p></li><li><p>重新打包</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asar pack app app.asar</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> TooLs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML&amp;类之间的关系</title>
      <link href="/2024/05/06/UML-%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
      <url>/2024/05/06/UML-%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>在Java中，类之间可以通过不同的关系进行连接和交互。以下是一些常见的类之间的关系：</p><p><img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/asserts_JavaSE/202405062156234.png"></p><img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/asserts_JavaSE/202405062213851.png" height="350" whidth="600"/><ol><li><p><strong>继承关系（Inheritance）&#x2F;泛化关系（is a）</strong>：</p><ul><li>在Java中，一个类可以继承另一个类。被继承的类称为父类或超类，继承的类称为子类。</li><li>子类可以继承父类的属性和方法，并且可以重写父类的方法或添加新的方法。</li><li>通过继承，可以实现代码的重用和层次化的设计。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog is barking&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>实现关系（Implementation）</strong>：</p><ul><li>在Java中，一个类可以实现一个接口或者扩展一个抽象类。</li><li>通过实现接口或抽象类，子类必须提供接口或抽象类定义的所有方法的具体实现。</li><li>实现关系使得多个类可以共享相同的行为，同时具备自己的特定实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">calculatePerimeter</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    Circle(<span class="type">double</span> radius) &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculatePerimeter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * Math.PI * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>关联关系（Association）</strong>：</p><ul><li>关联表示不同类之间的关联关系，通常是通过一个类中的成员变量引用另一个类的对象来实现的。</li><li>关联关系可以是单向的或双向的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    Engine engine;</span><br><span class="line"></span><br><span class="line">    Car(Engine engine) &#123;</span><br><span class="line">        <span class="built_in">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">    <span class="comment">// Engine class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>依赖关系（Dependency）</strong>：</p><ul><li>依赖关系表示一个类（或方法）依赖于另一个类（或方法）来完成其工作，但它们之间的关系比关联关系更弱。</li><li>通常表现为一个类作为另一个类的方法参数、局部变量或静态方法调用等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">(Engine engine)</span> &#123;</span><br><span class="line">        <span class="comment">// Method implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">    <span class="comment">// Engine class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>聚合关系（Aggregation）</strong>：</p><ul><li>聚合关系表示整体和部分之间的关系，整体对象和部分对象之间是“包含”的关系，但它们之间的生命周期可以不同。</li><li>聚合关系是一种弱的“拥有”关系，部分对象可以脱离整体而存在。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">University</span> &#123;</span><br><span class="line">    List&lt;Student&gt; students;</span><br><span class="line"></span><br><span class="line">    University(List&lt;Student&gt; students) &#123;</span><br><span class="line">        <span class="built_in">this</span>.students = students;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">// Student class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>组合关系（Composition）</strong>：</p><ul><li>组合关系也表示整体和部分之间的关系，但与聚合关系不同，组合关系中部分对象与整体对象具有相同的生命周期。</li><li>整体对象被销毁时，其部分对象也会被销毁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">House</span> &#123;</span><br><span class="line">    Room kitchen;</span><br><span class="line">    Room bedroom;</span><br><span class="line"></span><br><span class="line">    House() &#123;</span><br><span class="line">        kitchen = <span class="keyword">new</span> <span class="title class_">Room</span>();</span><br><span class="line">        bedroom = <span class="keyword">new</span> <span class="title class_">Room</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Room</span> &#123;</span><br><span class="line">    <span class="comment">// Room class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这些类之间的关系可以帮助我们在设计和组织Java程序时更好地理解和建模不同类之间的交互。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
          <category> UML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object类</title>
      <link href="/2024/05/06/Object%E7%B1%BB/"/>
      <url>/2024/05/06/Object%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><h2 id="一、Object类"><a href="#一、Object类" class="headerlink" title="一、Object类"></a>一、Object类</h2><p>在Java中，<code>Object</code> 类是所有类的根类。也就是说，所有的类都是直接或间接地继承自 <code>Object</code> 类。<br><code>Object</code> 类定义了一些所有对象都共享的方法，这些方法可以在任何类的对象上调用。</p><p>下面是一些 <code>Object</code> 类中常用的方法：</p><ol><li><p><strong><code>equals(Object obj)</code></strong>: 用于比较两个对象是否相等。默认情况下，<code>equals()</code> 方法比较的是对象的引用是否相同，但是可以在子类中重写该方法来定义自定义的相等性比较逻辑。</p></li><li><p><strong><code>hashCode()</code></strong>: 返回对象的哈希码值。这个方法通常与 <code>equals()</code> 方法一起使用，确保相等的对象具有相同的哈希码。</p></li><li><p><strong><code>toString()</code></strong>: 返回对象的字符串表示。默认情况下，<code>toString()</code> 方法返回一个由类名和对象的哈希码组成的<strong>字符串</strong>。</p></li><li><p><strong><code>getClass()</code></strong>: 返回对象的运行时类的引用，即 <code>Class</code> 对象。 </p></li><li><p><strong><code>clone()</code></strong>: 用于创建并返回一个对象的副本。要实现对象的克隆，需要在子类中实现 <code>Cloneable</code> 接口，并重写 <code>clone()</code> 方法。</p></li><li><p><strong><code>finalize()</code></strong>: 在垃圾收集器删除对象之前调用。可以在子类中重写该方法以执行资源清理等操作。</p></li><li><p><strong><code>notify()</code>, <code>notifyAll()</code>, <code>wait()</code></strong>: 这些方法是用于多线程编程的，用于线程之间的通信和同步。</p></li><li><p><strong><code>getClassLoader()</code></strong>: 返回对象的类加载器。</p></li></ol><h2 id="二、toString方法"><a href="#二、toString方法" class="headerlink" title="二、toString方法"></a>二、toString方法</h2><h3 id="2-1、Object类中的toString-方法。"><a href="#2-1、Object类中的toString-方法。" class="headerlink" title="2.1、Object类中的toString()方法。"></a>2.1、Object类中的toString()方法。</h3><img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/asserts_JavaSE/202405081635071.png" height="350" width="750"/><p>对Object类中的toString不满意可以重写。</p><blockquote><p>当println()输出的是一个引用的时候，会自动调用 “引用.toString()”</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//println底层源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(Object x)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(x);</span><br><span class="line">        <span class="keyword">if</span> (getClass() == PrintStream.class) &#123;</span><br><span class="line">            <span class="comment">// 自第一次调用以来，需要再次应用 String.valueOf</span></span><br><span class="line">            <span class="comment">// might return null</span></span><br><span class="line">            writeln(String.valueOf(s));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                print(s);</span><br><span class="line">                newLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//valueOf底层源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (obj == <span class="literal">null</span>) ? <span class="string">&quot;null&quot;</span> : obj.toString();  <span class="comment">//这里对空引用进行了处理，不会报空异常。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        car=<span class="literal">null</span>;</span><br><span class="line">        System.out.println(car);    <span class="comment">//输出null，源代码对null进行了处理。</span></span><br><span class="line">        System.out.println(car.toString());  <span class="comment">//输出空指针异常。</span></span><br><span class="line">        <span class="comment">//由源码可以看出。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、equals方法"><a href="#三、equals方法" class="headerlink" title="三、equals方法"></a>三、equals方法</h2><h3 id="3-1、Object类中的equals方法"><a href="#3-1、Object类中的equals方法" class="headerlink" title="3.1、Object类中的equals方法"></a>3.1、Object类中的equals方法</h3><p>Java中的equals()方法用于比较两个对象的内容是否相等。<br>在Object类中，equals()方法的默认实现是比较两个对象的引用是否相等（即是否指向同一块内存地址），这相当于使用&#x3D;&#x3D;运算符进行比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-运算符"><a href="#3-2-运算符" class="headerlink" title="3.2 &#x3D;&#x3D;运算符"></a>3.2 &#x3D;&#x3D;运算符</h3><blockquote><p>&#x3D;&#x3D;运算规则：比较两个变量中保存的值是否相等。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//==</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(a == b);    <span class="comment">//true</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">object1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        System.out.println(object1 == object2); <span class="comment">//false,两个引用保存的值不同，即地址不同。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为equal对于对象而言比较的是地址，即引用变量存储的值。但大多数我们想比较的是内容，所以要重写equals。<br>此外重写要彻底，因为你的一个对象比较可能涉及多个类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EG:</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较两个日期对象的内容是否相等。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj 要比较的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果两个日期对象的年、月、日都相等，则返回true；否则返回false</span></span><br><span class="line"><span class="comment"> * 注意：重写equals方法传参必须是Object，若不是则不能构成重写而是重载。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果传入的对象为null，则返回false</span></span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果传入的对象是当前对象的引用，直接返回true</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span> == obj) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果传入的对象是Date类型的实例，则进行内容比较</span></span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Date)&#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> (Date) obj; <span class="comment">//向下转型，涉及Date独特的方法。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.year == d.year &amp;&amp; <span class="built_in">this</span>.month == d.month &amp;&amp; <span class="built_in">this</span>.day == d.day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果传入的对象不是Date类型的实例，则返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、hashCode方法（入门）"><a href="#四、hashCode方法（入门）" class="headerlink" title="四、hashCode方法（入门）"></a>四、hashCode方法（入门）</h2><p>关于Object类的hashCode()方法：    </p><ul><li>hashCode：返回一个对象的哈希值，通常作为在哈希表中查找该对象的键值。</li><li>Object类的默认实现是根据对象的内存地址生成一个哈希码（即将对象的内存地址转换为整数作为哈希值）。</li><li>hashCode()方法是为了HashMap、Hashtable、HashSet等集合类进行优化而设置的，以便更快地查找和存储对象</li><li>hashCode()方法在Object类中的默认实现：</li><li>public native int hashCode();</li><li>这是一个本地方法，底层调用了C++写的动态链接库程序：xxx.dll</li></ul><h2 id="五、finalize方法（已过时，作为了解）"><a href="#五、finalize方法（已过时，作为了解）" class="headerlink" title="五、finalize方法（已过时，作为了解）"></a>五、finalize方法（已过时，作为了解）</h2><p>finalize：当java对象被回收时，<strong>由GC自动调用被回收对象的finalize方法</strong>，通常在该方法中完成<strong>销毁前</strong>的准备。从Java9开始，这个方法被标记已过时，不建议使用。作为了解。</p><ul><li>可以在finalize中进行关闭连接操作。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Object类中是这样实现的：很显然，这个方法是需要子类重写的。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EG</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span> + <span class="string">&quot;即将被回收&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">            p1 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 建议启动垃圾回收器（这只是建议启动垃圾回收器）</span></span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">1000</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.gc();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、clone方法"><a href="#六、clone方法" class="headerlink" title="六、clone方法"></a>六、clone方法</h2><p>在 <code>Object</code> 类中，<code>clone()</code> 方法被声明为 <code>protected</code>。它的签名如下：    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br></pre></td></tr></table></figure><p><code>clone()</code> 方法允许创建并返回一个对象的副本。但是，需要注意以下几点：    </p><ol><li><code>clone()</code> 方法在默认情况下是 <code>protected</code> 的，这意味着<strong>只有类本身或其子类可以调用这个方法</strong>。因此，如果你希望<strong>在类外部调用</strong> <code>clone()</code> 方法，必须在类中重新定义这个方法并将其设置为 <code>public</code>。</li><li>调用 <code>clone()</code> 方法时，被克隆的类<strong>必须</strong>实现 <code>Cloneable</code> 接口。否则，将会抛出 <code>CloneNotSupportedException</code> 异常。</li><li><code>clone()</code> 方法的实现通常由 <code>native</code> 关键字修饰，这表示它的实现是由底层的本地代码完成的。这使得 <code>clone()</code> 方法能够访问对象的内部状态，从而创建对象的精确副本。</li></ol><blockquote><p>使用 <code>clone()</code> 方法需要谨慎，因为它是浅拷贝，即它只复制了对象本身以及其引用的内部数据结构。如果对象包含其他对象的引用，那么这些引用仍然指向相同的内存地址。在这种情况下，你可能需要实现深拷贝来确保所有对象及其引用的对象都被正确复制。</p></blockquote><h3 id="6-1、浅克隆"><a href="#6-1、浅克隆" class="headerlink" title="6.1、浅克隆"></a>6.1、浅克隆</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.object2;</span><br><span class="line"><span class="comment">//标志接口就像是一张空白的身份证，没有任何个人信息，只有一张照片和一串特定的标签。</span></span><br><span class="line"><span class="comment">//当一个类实现了某个标志接口，就像给这个类的身份证上贴上了特定的标签，告诉别人这个类具备了某种特定的能力或性质。</span></span><br><span class="line"><span class="comment">//比如，如果一个类实现了 `Cloneable` 接口，就像给这个类的身份证上贴上了“可以被复制”的标签，这样其他人就知道这个类的对象可以使用 `clone()` 方法进行复制了。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;  <span class="comment">//凡事参加克隆的对象，必须实现一个标志接口：java.lang.Cloneable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浅克隆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="comment">// 创建User对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">20</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 克隆一个user对象</span></span><br><span class="line">        <span class="comment">// 报错原因：因为Object类中的clone()方法是protected修饰的。</span></span><br><span class="line">        <span class="comment">// protected修饰的只能在：本类，同包，子类中访问。</span></span><br><span class="line">        <span class="comment">// 但是以下这行代码不满足以上所说条件。</span></span><br><span class="line">        <span class="comment">// 这是一种浅克隆/浅拷贝。</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> user.clone();</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改克隆之后的对象的age属性</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">copyUser</span> <span class="operator">=</span> (User) obj;</span><br><span class="line">        copyUser.setAge(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆之后的新对象的年龄：&quot;</span> + copyUser.getAge());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;原始对象的年龄：&quot;</span> + user.getAge());</span><br><span class="line">        <span class="type">UserTest</span> <span class="variable">userTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserTest</span>();</span><br><span class="line">        userTest.clone();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2、深克隆"><a href="#6-2、深克隆" class="headerlink" title="6.2、深克隆"></a>6.2、深克隆</h3><p>深克隆解决的问题是在复制对象时，确保对象及其所有引用的对象都被完全复制，而不仅仅是复制了对象本身。<br>通常，当我们进行对象的复制时，如果对象包含了其他对象的引用，浅复制只是复制引用而不是复制引用的对象本身，<br>这样就会导致新对象和原对象共享相同的引用对象，一旦其中一个对象修改了共享的引用对象，另一个对象也会受到影响，这可能会导致意外的行为或错误的结果。</p><h4 id="6-2-1、浅克隆问题举例"><a href="#6-2-1、浅克隆问题举例" class="headerlink" title="6.2.1、浅克隆问题举例"></a>6.2.1、浅克隆问题举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EG：浅克隆问题</span></span><br><span class="line"><span class="keyword">package</span> com.camellia.object2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String street;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Address&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;city=&#x27;&quot;</span> + city + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, street=&#x27;&quot;</span> + street + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String city, String street)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">        <span class="built_in">this</span>.street = street;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCity</span><span class="params">(String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStreet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> street;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStreet</span><span class="params">(String street)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.street = street;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.javase.oop41;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address addr;  <span class="comment">//问题所在，包含其他对象的引用。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, Address addr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.addr = addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">getAddr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddr</span><span class="params">(Address addr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.addr = addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, addr=&quot;</span> + addr +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.javase.oop41;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建住址对象</span></span><br><span class="line">        <span class="type">Address</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;海淀&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建User对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;李四&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 克隆一个User对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> (User)user1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(user1);</span><br><span class="line">        System.out.println(user2);</span><br><span class="line"></span><br><span class="line">        user2.getAddr().setCity(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(user1);   <span class="comment">//原本的值受到影响。</span></span><br><span class="line">        System.out.println(user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2-2、深克隆举例"><a href="#6-2-2、深克隆举例" class="headerlink" title="6.2.2、深克隆举例"></a>6.2.2、深克隆举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改为深克隆，修改User clone方法。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">    <span class="comment">// 重写方法，让其达到深克隆的效果。</span></span><br><span class="line">    <span class="comment">// User要克隆，User对象关联的Address对象也需要克隆一份。</span></span><br><span class="line">    <span class="type">Address</span> <span class="variable">copyAddr</span> <span class="operator">=</span> (Address)<span class="built_in">this</span>.getAddr().clone();</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">copyUser</span> <span class="operator">=</span> (User)<span class="built_in">super</span>.clone();</span><br><span class="line">    copyUser.setAddr(copyAddr);</span><br><span class="line">    <span class="keyword">return</span> copyUser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同时Address也要重写clone方法。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
          <category> Java Part_1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java访问控制权限</title>
      <link href="/2024/05/06/Java%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90/"/>
      <url>/2024/05/06/Java%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<p>#Java访问控制权限</p><h2 id="一、对Java中访问控制权限修饰符的对比表格"><a href="#一、对Java中访问控制权限修饰符的对比表格" class="headerlink" title="一、对Java中访问控制权限修饰符的对比表格"></a>一、对Java中访问控制权限修饰符的对比表格</h2><table><thead><tr><th align="center">访问权限</th><th>同一类</th><th>同一包</th><th>子类</th><th>不同包的非子类</th></tr></thead><tbody><tr><td align="center">public</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr><tr><td align="center">protected</td><td>✓</td><td>✓</td><td>✓</td><td>✗</td></tr><tr><td align="center">default</td><td>✓</td><td>✓</td><td>✗</td><td>✗</td></tr><tr><td align="center">private</td><td>✓</td><td>✗</td><td>✗</td><td>✗</td></tr></tbody></table><h2 id="二、Java访问控制符"><a href="#二、Java访问控制符" class="headerlink" title="二、Java访问控制符"></a>二、Java访问控制符</h2><p>在Java中，访问控制权限是通过关键字 <code>public</code>, <code>protected</code>, <code>default</code> (也称为 package-private)，以及 <code>private</code> 来实现的。这些关键字用于控制类、变量、方法和构造函数的访问级别。</p><ol><li><p><strong>public</strong>: 公共访问级别，被声明为 <code>public</code> 的类、方法、变量可以被任何其他类访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> myVariable;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Some code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>protected</strong>: 受保护的访问级别，被声明为 <code>protected</code> 的成员可以被同一包内的其他类访问，以及继承该类的子类访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> myVariable;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Some code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>default (package-private)</strong>: 默认的访问级别，没有明确声明访问修饰符的类、方法、变量拥有默认的访问级别，它们只能被同一包内的其他类访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> myVariable;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Some code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>private</strong>: 私有访问级别，被声明为 <code>private</code> 的成员只能在声明它们的类内部访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> myVariable;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Some code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、修饰对象"><a href="#三、修饰对象" class="headerlink" title="三、修饰对象"></a>三、修饰对象</h2><ol><li><p><strong>类级别的修饰符</strong>：</p><ul><li><code>public</code>: 允许类被任何其他类访问。</li><li><code>default</code> (没有修饰符): 允许类在同一包内被访问，但在不同包内不能被访问。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123; &#125; <span class="comment">// 公共类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123; &#125; <span class="comment">// 默认访问级别的类，即包访问权限</span></span><br></pre></td></tr></table></figure></li><li><p><strong>局部变量</strong>：局部变量是在方法、构造函数或块中声明的变量。它们不能使用访问控制权限修饰符进行修饰，因为它们的作用范围限定在声明它们的块内部，超出这个范围就无法访问。</p></li><li><p><code>public</code>,<code> protected</code>, <code>default</code>,<code> private</code> 这四种访问控制权限修饰符可以用来修饰实例方法、静态方法、静态变量和实例变量。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
          <category> Java Part_1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java接口</title>
      <link href="/2024/05/05/%E6%8E%A5%E5%8F%A3/"/>
      <url>/2024/05/05/%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>在 Java 中，<strong>接口是一种引用数据类型</strong>。它定义了一组抽象方法。<br>其他类可以实现这些接口，并提供方法的具体实现。<br>使用接口可以实现多重继承，因为一个类可以实现多个接口。</p><h2 id="一、接口定义"><a href="#一、接口定义" class="headerlink" title="一、接口定义"></a>一、接口定义</h2><ol><li>接口使用 interface 关键字定义。接口中的方法默认<strong>是公共的抽象方法</strong>，可以包含常量、默认方法（Java 8 引入的特性）、静态方法（Java 8 引入的特性）等。   </li><li>接口没有构造方法，也无法实例化。</li><li>类和接口的关系我们叫做实现（这里的实现也可以等同看做继承）。使用implements关键字进行接口的实现。</li><li>一个非抽象的类实现接口必须将接口中所有的抽象方法全部实现（强制要求的，要不然编译器报错。）</li><li>所有接口隐式的继承Object，所以也可调用Object中的方法。</li></ol><h3 id="1-1、接口结合多态"><a href="#1-1、接口结合多态" class="headerlink" title="1.1、接口结合多态"></a>1.1、接口结合多态</h3><blockquote><p>*接口是一种引用数据类型</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个形状接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆形类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> length;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">double</span> length, <span class="type">double</span> width)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.length = length;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> length * width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多态：调用不同对象的相同方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Circle area: &quot;</span> + shape1.calculateArea());</span><br><span class="line">        System.out.println(<span class="string">&quot;Rectangle area: &quot;</span> + shape2.calculateArea());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-2、接口JDK8和JDK9新特性"><a href="#1-2、接口JDK8和JDK9新特性" class="headerlink" title="1.2、接口JDK8和JDK9新特性"></a>1.2、接口JDK8和JDK9新特性</h3><h4 id="1-2-2、JDK8-新特性"><a href="#1-2-2、JDK8-新特性" class="headerlink" title="1.2.2、JDK8 新特性"></a>1.2.2、JDK8 新特性</h4><p><strong>默认方法 (Default Methods)：</strong><br>Java 8 允许在接口中定义默认方法，这些方法可以在接口中提供默认的实现。<br>这样的好处是，当接口被多个类实现时，可以避免因为在接口中添加新方法而导致所有实现类都需要实现新方法的问题。<br>默认方法使用<code>default</code>关键字进行声明。    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Vehicle is stopping&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        car.stop();  <span class="comment">// 通过实例变量调用默认方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过接口名称调用默认方法(多态)</span></span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">vehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        vehicle.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>静态方法 (Static Methods)：</strong><br>Java 8 允许在接口中定义静态方法，这些方法只能通过接口名称调用，也就是接口可以当做工具来使用。<br>静态方法使用<code>static</code>关键字进行声明。    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is a vehicle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 调用接口的静态方法</span></span><br><span class="line">        Vehicle.info();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-3、JDK9-新特性"><a href="#1-2-3、JDK9-新特性" class="headerlink" title="1.2.3、JDK9 新特性"></a>1.2.3、JDK9 新特性</h4><p><strong>私有方法 (Private Methods)：为默认方法服务</strong><br>Java 9 允许在接口中定义私有方法，这些方法<strong>只能</strong>被接口中的其他默认方法调用，对于接口的实现类是不可见的。<br>私有方法使用 <code>private</code> 关键字进行声明。    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Vehicle is stopping&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用私有方法</span></span><br><span class="line">        stopEngine();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">stopEngine</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Engine is stopping&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>私有静态方法 (Private Static Methods)：为静态方法服务</strong><br>Java 9 进一步允许在接口中定义私有静态方法，这些方法可以在接口中被其他静态方法中被调用。<br>私有静态方法使用<code>private static</code>关键字进行声明。   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is a vehicle&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用私有静态方法</span></span><br><span class="line">        showInfo();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 另一个私有静态方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Vehicle information&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>引入私有方法和私有静态方法目的是为了让默认方法和静态方法中的代码结构更清晰，默认方法和静态方法很有可能要实现大量的代码，全在里面写就很乱。</p></blockquote><h2 id="二、接口的作用"><a href="#二、接口的作用" class="headerlink" title="二、接口的作用"></a>二、接口的作用</h2><h3 id="2-1、没使用接口"><a href="#2-1、没使用接口" class="headerlink" title="2.1、没使用接口"></a>2.1、没使用接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.interface1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 硬盘类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HardDrive</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;硬盘开始读数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;硬盘开始写数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.interface1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印机类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打印机开始读取数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打印机开始打印文件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.interface1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 电脑类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">conn</span><span class="params">(HardDrive hardDrive)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接设备成功&quot;</span>);</span><br><span class="line">        hardDrive.read();</span><br><span class="line">        hardDrive.write();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">conn</span><span class="params">(Printer printer)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接设备成功&quot;</span>);</span><br><span class="line">        printer.read();</span><br><span class="line">        printer.write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.interface1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个程序没有使用接口。分析存在哪些缺点？</span></span><br><span class="line"><span class="comment"> *      违背OCP开闭原则。</span></span><br><span class="line"><span class="comment"> *      Computer类的扩展力差。</span></span><br><span class="line"><span class="comment"> *      为什么？</span></span><br><span class="line"><span class="comment"> *          Computer类中使用了HardDriver类，以及Printer类。</span></span><br><span class="line"><span class="comment"> *          导致Computer类和HardDrive，Printer耦合度太高。</span></span><br><span class="line"><span class="comment"> *          Computer类扩展力太差。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建硬盘对象</span></span><br><span class="line">        <span class="type">HardDrive</span> <span class="variable">hardDrive</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HardDrive</span>();</span><br><span class="line">        <span class="comment">// 创建电脑对象</span></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="comment">// 电脑连接硬盘</span></span><br><span class="line">        computer.conn(hardDrive);</span><br><span class="line">        <span class="comment">// 创建打印机对象</span></span><br><span class="line">        <span class="type">Printer</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Printer</span>();</span><br><span class="line">        <span class="comment">// 电脑连接打印机</span></span><br><span class="line">        computer.conn(printer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2使用接口"><a href="#2-2使用接口" class="headerlink" title="2.2使用接口"></a>2.2使用接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.interface1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个抽象的Usb接口。</span></span><br><span class="line"><span class="comment"> * 调用者是Computer</span></span><br><span class="line"><span class="comment"> * 实现者是HardDrive和Printer</span></span><br><span class="line"><span class="comment"> * 调用者和实现者都是面向Usb接口写代码的。</span></span><br><span class="line"><span class="comment"> * 接口将Computer和具体的设备解耦合了。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Usb</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.interface1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 硬盘是实现者。面向Usb接口写实现类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HardDrive</span> <span class="keyword">implements</span> <span class="title class_">Usb</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;硬盘开始读数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;硬盘开始写数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.interface1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印机是实现者。面向Usb接口写实现类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Printer</span> <span class="keyword">implements</span> <span class="title class_">Usb</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打印机开始读数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打印机开始打印文件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.interface1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 电脑类</span></span><br><span class="line"><span class="comment"> * 面向Usb接口调用方法即可。</span></span><br><span class="line"><span class="comment"> * 这是调用者。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">conn</span><span class="params">(Usb usb)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接设备成功&quot;</span>);</span><br><span class="line">        usb.read();</span><br><span class="line">        usb.write();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.javase.oop31;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用了接口，分析有什么好处？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建硬盘对象</span></span><br><span class="line">        <span class="type">HardDrive</span> <span class="variable">hardDrive</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HardDrive</span>();</span><br><span class="line">        <span class="comment">// 创建电脑对象</span></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="comment">// 连接设备</span></span><br><span class="line">        computer.conn(hardDrive);</span><br><span class="line">        <span class="comment">// 创建打印机对象</span></span><br><span class="line">        <span class="type">Printer</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Printer</span>();</span><br><span class="line">        <span class="comment">// 连接设备</span></span><br><span class="line">        computer.conn(printer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其实就是接口+多态才能发挥其作用，原理和使用继承+多态一样。<br>最重要的还是理解多态。</p></blockquote><h2 id="三、接口和抽象类如何选择？"><a href="#三、接口和抽象类如何选择？" class="headerlink" title="三、接口和抽象类如何选择？"></a>三、接口和抽象类如何选择？</h2><ol><li>抽象类主要适用于公共代码的提取。当多个类有共同的属性和方法时，为了达到代码复用，建议为这几个类提取出一个父类，在该父类中编写公共代码。<br>如果有一些方法无法在该类中实现，可以延迟到子类中实现，这样的类就应该用抽象类。</li><li>接口主要用于实现功能的扩展。例如有很多类，一些类需要这个方法，另一些类不需要这个方法时，就可以将该方法定义到接口中。<br>需要这个方法的类就去实现这个接口，不需要这个方法的就可以不实现这个接口。</li></ol><p>​               <a href="https://github.com/camelliaxiaohua/JavaWorkplace/tree/master/Java_SE_Part_1/src/com/camellia/interface2">接口和抽象类如何选取代码理解</a></p><h2 id="四、接口和类之间的上下转换"><a href="#四、接口和类之间的上下转换" class="headerlink" title="四、接口和类之间的上下转换"></a>四、接口和类之间的上下转换</h2><p>###4.1、接口和类之间上下转换的几种方式实现<br>在Java中，接口和类之间的上下转换可以通过以下几种方式实现：</p><ol><li><p><strong>接口引用指向实现类对象</strong>：可以使用接口类型的引用变量来引用实现了该接口的类的对象。这是一种向上转型的操作，因为接口是父类，而实现类是子类。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woof&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">dog.makeSound(); <span class="comment">// 输出: Woof</span></span><br></pre></td></tr></table></figure></li><li><p><strong>强制类型转换</strong>：如果有必要，可以将接口类型的引用强制转换为实现类类型，但在转换之前必须进行类型检查以避免<code>ClassCastException</code>。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">realDog</span> <span class="operator">=</span> (Dog) animal;  <span class="comment">//做出这种转换一般是需要用到Dog中独有的方法</span></span><br><span class="line">    realDog.makeSound(); <span class="comment">// 输出: Woof</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>将类对象向下转换为接口对象</strong>：如果一个类实现了某个接口，那么该类的对象也可以被视为实现了该接口的对象。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woof&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> dog; <span class="comment">// 向上转型</span></span><br><span class="line">animal.makeSound(); <span class="comment">// 输出: Woof</span></span><br></pre></td></tr></table></figure></li></ol><p>总的来说，接口和类之间的上下转换可以帮助实现代码的灵活性和可维护性，使得代码更容易扩展和修改。</p><h3 id="4-2、接口和类之间的上下转换-父类与子类的上下转换的细微区分"><a href="#4-2、接口和类之间的上下转换-父类与子类的上下转换的细微区分" class="headerlink" title="4.2、接口和类之间的上下转换&amp;父类与子类的上下转换的细微区分"></a>4.2、接口和类之间的上下转换&amp;父类与子类的上下转换的细微区分</h3><p>在Java中，接口和类之间的上下转换与父类与子类之间的上下转换有相似之处，但也有一些重要的区别：</p><ol><li><p><strong>父类与子类之间的上下转换</strong>：</p><ul><li>父类对象可以显式转换为子类对象，但需要进行类型检查以避免<code>ClassCastException</code>。</li><li>这种转换是显式的，需要使用强制类型转换。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) animal; <span class="comment">// 需要强制类型转换</span></span><br></pre></td></tr></table></figure></li><li><p><strong>接口与实现类之间的上下转换</strong>：</p><ul><li>接口对象不能直接转换为实现类对象，因为接口不能实例化。</li><li>必须先创建实现类的对象，然后将其转换为接口类型的引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) animal; <span class="comment">// 需要强制类型转换</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>在Java中，接口与实现类之间的上下转换不会引发 <code>ClassCastException</code>，因为接口对象引用&gt;的是实现类的实例。</p></blockquote><p>例如，假设有以下的接口 <code>Animal</code> 和实现类 <code>Dog</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>然后执行以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// 上转换</span></span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) animal; <span class="comment">// 下转换</span></span><br></pre></td></tr></table></figure><p>这种情况下，上述的下转换是安全的，不会引发 <code>ClassCastException</code>，因为在执行上转换时，<code>animal</code>引用指向的是 <code>Dog</code> 类的实例，因此它可以被成功地下转换为 <code>Dog</code> 类型。</p><p><code>ClassCastException</code> 主要发生在向下转换时，如果在转换之前没有进行适当的类型检查，且转换的目标对象不是期望的类型，则会抛出 <code>ClassCastException</code> 异常。但是在接口与实现类之间的转换中，由于实现类确实是接口的实例，所以这种情况下是安全的。</p>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
          <category> Java Part_1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象方法&amp;抽象类</title>
      <link href="/2024/05/05/%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95-%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
      <url>/2024/05/05/%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95-%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="抽象类-抽象方法"><a href="#抽象类-抽象方法" class="headerlink" title="抽象类&amp;抽象方法"></a>抽象类&amp;抽象方法</h1><h2 id="一、抽象方法"><a href="#一、抽象方法" class="headerlink" title="一、抽象方法"></a>一、抽象方法</h2><p>父类中无法确定实现的方法，每个子类业务需求不一样，建议定义为抽象方法。    </p><h3 id="1-1、抽象方法定义"><a href="#1-1、抽象方法定义" class="headerlink" title="1.1、抽象方法定义"></a>1.1、抽象方法定义</h3><ul><li>在Java中，抽象方法是指没有具体实现代码的方法，而只有方法声明。</li><li>public和abstract关键字的顺序没有要求。</li><li>当一个类<strong>有</strong>抽象方法，Java要求该类必须<strong>是</strong>抽象的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个抽象方法</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、抽象类"><a href="#二、抽象类" class="headerlink" title="二、抽象类"></a>二、抽象类</h2><p>当一个类具有一些通用的特性或行为，但又不能完全实现它们，或者希望强制子类来实现一些方法时，就可以考虑将这个类定义为抽象类，在抽象类中只提供公共代码。    </p><h3 id="2-1-抽象类定义"><a href="#2-1-抽象类定义" class="headerlink" title="2.1 抽象类定义"></a>2.1 抽象类定义</h3><ul><li><code>abstract class 类名&#123;&#125;</code>    </li><li>抽象类有构造方法，但无法实例化（即无法创建对象，但是其目的是给子类用的，子类可以通过super调用）。   </li><li>抽象类中不一定有抽象方法，但是有抽象方法必须是抽象类。    </li><li>一个非抽象类继承抽象类，必须将所有抽象方法进行实现&#x2F;重写。</li><li>abstract关键字不能和private、final、static关键字共存。</li></ul><h2 id="三、一个抽象类的练习。"><a href="#三、一个抽象类的练习。" class="headerlink" title="三、一个抽象类的练习。"></a>三、一个抽象类的练习。</h2><p>一个抽象类的练习，涉及super、final、抽象类、静态变量调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop10;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象形状类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;未知&quot;</span>; <span class="comment">// 形状名称，默认为&quot;未知&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">color</span> <span class="operator">=</span> <span class="string">&quot;未知&quot;</span>; <span class="comment">// 形状颜色，默认为&quot;未知&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法：计算形状的面积</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">area</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示形状的名称和颜色</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">(String name, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取形状名称</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置形状名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取形状颜色</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置形状颜色</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop10;</span><br><span class="line"><span class="comment">//一个项目中通常会有个常量类，专门用来存储产量。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> IP=<span class="number">3.14159265358979323846</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop10;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆形类，继承自形状类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> radius; <span class="comment">// 圆的半径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(String name, String color, <span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, color); <span class="comment">// 调用父类的构造方法初始化名称和颜色</span></span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写父类的抽象方法，计算圆的面积</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">area</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Area of circle: &quot;</span> + Constant.PI * <span class="built_in">this</span>.radius * <span class="built_in">this</span>.radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取圆的半径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getRadius</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置圆的半径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRadius</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.camellia.oop10;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形类，继承自形状类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> width; <span class="comment">// 矩形的宽度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> height; <span class="comment">// 矩形的高度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(String name, String color, <span class="type">double</span> width, <span class="type">double</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, color); <span class="comment">// 调用父类的构造方法初始化名称和颜色</span></span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写父类的抽象方法，计算矩形的面积</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">area</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Area of Rectangle: &quot;</span> + <span class="built_in">this</span>.height * <span class="built_in">this</span>.width);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="string">&quot;圆形&quot;</span>,<span class="string">&quot;绿色&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        circle.display();</span><br><span class="line">        circle.area();</span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="string">&quot;矩形&quot;</span>, <span class="string">&quot;粉色&quot;</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">        rectangle.display();</span><br><span class="line">        rectangle.area();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
          <category> Java Part_1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>final关键字</title>
      <link href="/2024/05/04/final%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2024/05/04/final%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><ul><li><p><strong>不可继承类：</strong>  使用 “final” 关键字修饰的类表示该类不能被继承。</p></li><li><p><strong>不可覆盖方法：</strong> 在父类中使用 “final” 关键字修饰的方法表示该方法不能被子类覆盖（即不能被重写）。</p></li><li><p><strong>不可变变量：</strong> 使用 “final” 关键字声明的变量是不可变的，一旦赋值后就不能再修改其值。这在创建常量时很有用。</p><ul><li>final修饰的实例变量，必须在构造方法执行完之前手动上赋值，不能采用系统默认值。</li><li><strong>常量定义规范：</strong>   <code>public static final 数据类型 常量名 = 常量值;</code></li></ul></li><li><p><strong>不可变对象：</strong>在Java中，final修饰的引用变量意味着该变量不能再指向其他对象，但并不意味着其所指向的对象是不可变的。即使引用变量是final的，对象本身的状态仍然可以改变。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可继承类</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FinalClass</span> &#123;</span><br><span class="line">    <span class="comment">// 该类的内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 试图继承不可继承类会导致编译错误</span></span><br><span class="line"><span class="comment">// class SubClass extends FinalClass &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// 不可覆盖的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">finalMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 方法的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试覆盖父类的final方法会导致编译错误</span></span><br><span class="line">    <span class="comment">// public void finalMethod() &#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">// 不可变变量 - 常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONSTANT</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// final修饰的实例变量，在构造方法中手动赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> instanceVariable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Main</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        instanceVariable = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可变对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        <span class="comment">// 尝试改变引用的指向会导致编译错误</span></span><br><span class="line">        <span class="comment">// sb = new StringBuilder(&quot;World&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尽管引用是final的，但对象本身的状态可以改变</span></span><br><span class="line">        sb.append(<span class="string">&quot; World&quot;</span>);</span><br><span class="line">        System.out.println(sb.toString()); <span class="comment">// 输出：Hello World</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
          <category> Java Part_1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Super关键字</title>
      <link href="/2024/05/04/Super%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2024/05/04/Super%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h1><ul><li>在Java中，this代表的是当前对象，super代表的是当前对象中的父亲特征。    </li><li>super不能使用在静态上下文中。    </li><li>在构造方法中调用父类构造方法或者父类和子类中存在同名实例变量、实例方法时super关键字不可省略。</li></ul><h2 id="一、super内存图"><a href="#一、super内存图" class="headerlink" title="一、super内存图"></a>一、super内存图</h2><p><img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/asserts_JavaSE/202405040551175.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop24;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String email;</span><br><span class="line">    String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">       Getter();</span><br><span class="line">       Setter(); <span class="comment">//省略</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">//     实例方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人类正在做一些事情！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop24;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  子类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//特有的属性：工资</span></span><br><span class="line">    <span class="type">double</span> sal;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name, <span class="type">int</span> age, String email, String address, <span class="type">double</span> sal)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">        <span class="built_in">this</span>.sal = sal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Setter();</span><br><span class="line">    Getter();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span> + <span class="built_in">this</span>.age);</span><br><span class="line">        System.out.println(<span class="string">&quot;邮箱：&quot;</span> + <span class="built_in">this</span>.email);</span><br><span class="line">        System.out.println(<span class="string">&quot;住址：&quot;</span> + <span class="built_in">this</span>.address);</span><br><span class="line">        System.out.println(<span class="string">&quot;工资：&quot;</span> + <span class="built_in">this</span>.sal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、super不能缺省的几种情况"><a href="#二、super不能缺省的几种情况" class="headerlink" title="二、super不能缺省的几种情况"></a>二、super不能缺省的几种情况</h2><ul><li>如果父类和子类中存在同名的实例变量，为了明确指定使用父类的实例变量，必须使用 super 关键字来引用父类的实例变量。</li><li>子类重写了父类方法，当想调用的时候必须使用 super 关键字来引用父类的实例方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop24;</span><br><span class="line"><span class="comment">//父类同上。</span></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//特有的属性：工资</span></span><br><span class="line">    <span class="type">double</span> sal;</span><br><span class="line">    <span class="comment">//name属性和父类属性同名。</span></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name, <span class="type">int</span> age, String email, String address, <span class="type">double</span> sal)</span> &#123;</span><br><span class="line">        <span class="comment">//子类构造方法不写super也会调用父类无参构造，因为隐式调用了super();</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">        <span class="built_in">this</span>.sal = sal;</span><br><span class="line">        <span class="comment">//父类name为null。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSal</span><span class="params">(<span class="type">double</span> sal)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sal = sal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">       </span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + <span class="built_in">super</span>.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span> + <span class="built_in">super</span>.age);</span><br><span class="line">        System.out.println(<span class="string">&quot;邮箱：&quot;</span> + <span class="built_in">super</span>.email);</span><br><span class="line">        System.out.println(<span class="string">&quot;住址：&quot;</span> + <span class="built_in">super</span>.address);</span><br><span class="line">        System.out.println(<span class="string">&quot;工资：&quot;</span> + <span class="built_in">this</span>.sal);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span> + <span class="built_in">this</span>.age);</span><br><span class="line">        System.out.println(<span class="string">&quot;邮箱：&quot;</span> + <span class="built_in">this</span>.email);</span><br><span class="line">        System.out.println(<span class="string">&quot;住址：&quot;</span> + <span class="built_in">this</span>.address);</span><br><span class="line">        System.out.println(<span class="string">&quot;工资：&quot;</span> + <span class="built_in">this</span>.sal);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 重写的要求：要求在父类方法的执行基础之上额外再添加一些代码。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;do some开始执行了&quot;</span>);</span><br><span class="line">        <span class="comment">// super. 什么时候不能省略？父中有，子中有相同的，但是想在子类中访问父的，必须添加 super.</span></span><br><span class="line">        <span class="built_in">super</span>.doSome();</span><br><span class="line">        System.out.println(<span class="string">&quot;do some方法执行结束了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// this本身是一个引用。所以可以直接输出。</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// super本身不是一个引用。super只是代表了当前对象的父类型特征那部分，况且super能输出，是输出它父类，还是父类的父类？</span></span><br><span class="line">        <span class="comment">// super 不能够单独的输出。</span></span><br><span class="line">        <span class="comment">//System.out.println(super); // 编译报错。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在子类构造方法中调用父类构造方法要使用super    <ul><li>在子类构造方法中调用父类构造方法时，必须放在子类构造方法的第一行，否则编译器会报错。这是因为在创建子类对象时，首先需要初始化父类的部分。</li><li>如果子类的构造方法没有显式地调用super(参数)，也没有显示的调用this(参数)，Java 编译器会默认插入对父类无参构造方法的调用，若父类没有无参则报错。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类构造方法</span></span><br><span class="line">    Parent(<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent class constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类构造方法</span></span><br><span class="line">    Child(<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">        <span class="built_in">super</span>(x);</span><br><span class="line">        <span class="comment">// 调用父类构造方法，必须放在子类构造方法的第一行,好处是增加代码复用。</span></span><br><span class="line">        <span class="comment">// 通过子类构造方法调用父类构造方法是为了给继承过来的父类型特征初始化。</span></span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child class constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Child</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p><strong>注意：</strong><br>在我们定义了有参构造方法后，尽量再定义无参构造方法以避免以上错误。 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
          <category> Java Part_1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态</title>
      <link href="/2024/05/03/%E5%A4%9A%E6%80%81/"/>
      <url>/2024/05/03/%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="一、类型转换"><a href="#一、类型转换" class="headerlink" title="一、类型转换"></a>一、类型转换</h2><h3 id="1-1、基本数据类型转换"><a href="#1-1、基本数据类型转换" class="headerlink" title="1.1、基本数据类型转换"></a>1.1、基本数据类型转换</h3><p>在Java中，基本数据类型之间可以进行自动类型转换和强制类型转换。</p><ol><li><p><strong>自动类型转换（隐式类型转换）</strong>：当一个表达式中包含不同类型的数据时，系统会自动将其中的低精度数据类型转换为高精度数据类型，以保证精度不丢失。</p><p>自动类型转换的规则如下：</p><ul><li>byte、short、char类型会自动提升为int类型。</li><li>如果表达式中包含了不同类型的数据，系统会自动将低精度的类型转换为高精度的类型。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> x; <span class="comment">// 自动将int类型转换为double类型</span></span><br></pre></td></tr></table></figure></li><li><p><strong>强制类型转换（显式类型转换）</strong>：在某些情况下，需要将一个数据类型转换为另一个数据类型，这时就需要使用强制类型转换。强制类型转换可以通过将目标类型的数据类型放在被转换的数据类型前面的括号中实现。</p><p>强制类型转换的规则如下：</p><ul><li>数据类型范围大的可以强制转换为数据类型范围小的，但可能会导致精度丢失或溢出。</li><li>强制类型转换可能会造成数据丢失或溢出，因此需要谨慎使用。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10.5</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">int</span>) a; <span class="comment">// 强制将double类型转换为int类型</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="1-2、Java中的向上转型和向下转型"><a href="#1-2、Java中的向上转型和向下转型" class="headerlink" title="1.2、Java中的向上转型和向下转型"></a>1.2、Java中的向上转型和向下转型</h3><p>在Java中，向上转型（Upcasting）和向下转型（Downcasting）是面向对象编程中常用的概念，<strong>用于处理类之间的继承关系</strong>。   </p><img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/asserts_JavaSE/202405011256547.png"  width="400px" height="400px"><ol><li><p><strong>向上转型（Upcasting）</strong>：向上转型是指将子类对象赋值给父类引用变量的过程。这样做是安全的，因为子类对象拥有父类的所有属性和方法。向上转型可以实现多态性，使得代码更加灵活。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// 向上转型</span></span><br></pre></td></tr></table></figure></li><li><p><strong>向下转型（Downcasting）</strong>：向下转型是指将父类引用变量转换为子类对象的过程。这种转型可能会导致异常，因为编译器只知道变量的编译时类型，而不知道实际的运行时类型。因此，在进行向下转型时，需要使用强制类型转换，并且需要确保转换是安全的，即实际对象是子类的实例。否则，会抛出 <code>ClassCastException</code> 异常。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// 向上转型</span></span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) animal; <span class="comment">// 向下转型</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>需要注意的是，向上转型是自动的，不需要显式地指定类型转换，而向下转型需要显式地使用强制类型转换，并且可能会导致异常，因此需要谨慎使用。</p></blockquote><h2 id="二、多态"><a href="#二、多态" class="headerlink" title="二、多态"></a>二、多态</h2><ol><li>父类型引用指向子类型对象。 <code>Animal a=new Cat(); a.move();</code>     </li><li>程序分为编译阶段和运行阶段<ul><li>编译阶段：编译器只知道a是Animal类型，因此去Animal类找move()方法，找到后，绑定成功，编译通过。这个过程通常被称为静态绑定。</li><li>运行阶段：运行时和JVM堆内存中真实的Java对象有关，所以运行时会自动调用真实对象move()方法。这个过程通常被称为动态绑定。</li></ul></li><li>多态是指：多种形态，编译阶段一种形态，运行阶段另一种形态。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">package</span> com.camellia.oop19;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;动物在移动&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;正在吃东西&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Bird 子类</span></span><br><span class="line"><span class="keyword">package</span> com.camellia.oop19;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸟儿在飞翔&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法也是子类特有的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸟儿在歌唱！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Cat 子类</span></span><br><span class="line"><span class="keyword">package</span> com.camellia.oop19;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫在走猫步&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法/行为是子类特有的。父类没有。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫在抓老鼠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1、发生在向上转型时的多态"><a href="#2-1、发生在向上转型时的多态" class="headerlink" title="2.1、发生在向上转型时的多态"></a>2.1、发生在向上转型时的多态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop19;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        java程序包括两个重要的阶段：</span></span><br><span class="line"><span class="comment">//            第一阶段：编译阶段</span></span><br><span class="line"><span class="comment">//                在编译的时候，编译器只知道a2的类型是Animal类型。</span></span><br><span class="line"><span class="comment">//                因此在编译的时候就会去Animal类中找move()方法。</span></span><br><span class="line"><span class="comment">//                找到之后，绑定上去，此时发生静态绑定。能够绑定</span></span><br><span class="line"><span class="comment">//                成功，表示编译通过。</span></span><br><span class="line"><span class="comment">//            第二阶段：运行阶段</span></span><br><span class="line"><span class="comment">//                在运行的时候，堆内存中真实的java对象是Cat类型。</span></span><br><span class="line"><span class="comment">//                所以move()的行为一定是Cat对象发生的。</span></span><br><span class="line"><span class="comment">//                因此运行的时候就会自动调用Cat对象的move()方法。</span></span><br><span class="line"><span class="comment">//                这种绑定称为运行期绑定/动态绑定。</span></span><br><span class="line"><span class="comment">//                </span></span><br><span class="line"><span class="comment">//            因为编译阶段是一种形态，运行的时候是另一种形态。因此得名：多态。</span></span><br><span class="line"></span><br><span class="line">        a2.move();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        以下代码是编译错误，因为编译器只知道a2是Animal类型，去Animal类中找</span></span><br><span class="line"><span class="comment">//        catchMouse()方法了，结果没有找到，无法完成静态绑定，编译报错。</span></span><br><span class="line"></span><br><span class="line">        a2.catchMouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2、发生在向下转型时的多态"><a href="#2-2、发生在向下转型时的多态" class="headerlink" title="2.2、发生在向下转型时的多态"></a>2.2、发生在向下转型时的多态</h3><blockquote><p><strong>注意：</strong> 向下转型使用不当容易发生类型转换异常：ClassCastExcetion。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop19;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        假如现在就是要让a2去抓老鼠，怎么办？</span></span><br><span class="line"><span class="comment">//            向下转型：downcasting（父---&gt;子）</span></span><br><span class="line"><span class="comment">//        什么时候我们会考虑使用向下转型？</span></span><br><span class="line"><span class="comment">//            当调用的方法是子类中特有的方法。</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c2</span> <span class="operator">=</span> (Cat) a2;</span><br><span class="line">        c2.catchMouse();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//         多态</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="comment">//         向下转型</span></span><br><span class="line">        <span class="type">Bird</span> <span class="variable">y</span> <span class="operator">=</span> (Bird) x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//         为什么编译的时候可以通过？</span></span><br><span class="line"><span class="comment">//             因为x是Animal类型，Animal和Bird之间存在继承关系，语法没问题，所以编译通过了。</span></span><br><span class="line"><span class="comment">//         为什么运行的时候出现ClassCastException（类型转换异常）？</span></span><br><span class="line"><span class="comment">//             因为运行时堆中真实对象是Cat对象，Cat无法转换成Bird，则出现类型转换异常。</span></span><br><span class="line"><span class="comment">//         为什么向下转型容易出问题？</span></span><br><span class="line"><span class="comment">//             因为向下转型将父类x转换成子类y，原则上没问题，子类的都继承了父类的方法，但是x真实指向的堆中不一定是父类。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3、用instanceof运算符避免向下转型时的风险"><a href="#2-3、用instanceof运算符避免向下转型时的风险" class="headerlink" title="2.3、用instanceof运算符避免向下转型时的风险"></a>2.3、用instanceof运算符避免向下转型时的风险</h3><p><code>instanceof</code> 运算符用于检查对象是否是特定类的实例，或者是否是特定类的子类的实例。它的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object <span class="keyword">instanceof</span> ClassName</span><br></pre></td></tr></table></figure><p>其中 <code>object</code> 是要检查的对象，<code>ClassName</code> 是要检查的类名。</p><p><code>instanceof</code> 运算符的返回结果是一个布尔值，如果 <code>object</code> 是 <code>ClassName</code> 的一个实例或子类的实例，则返回 <code>true</code>；否则返回 <code>false</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop19;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//         多态</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="comment">//         向下转型</span></span><br><span class="line">        <span class="type">Bird</span> <span class="variable">y</span> <span class="operator">=</span> (Bird) x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//         instanceof运算符的出现，可以解决ClassCastException异常。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        instanceof 运算符的语法规则：</span></span><br><span class="line"><span class="comment">//            1. instanceof运算符的结果一定是：true/false</span></span><br><span class="line"><span class="comment">//            2. 语法格式：</span></span><br><span class="line"><span class="comment">//                (引用 instanceof 类型)</span></span><br><span class="line"><span class="comment">//            3. 例如：</span></span><br><span class="line"><span class="comment">//                (a instanceof Cat)</span></span><br><span class="line"><span class="comment">//                    true表示什么？</span></span><br><span class="line"><span class="comment">//                        a引用指向的对象是Cat类型。</span></span><br><span class="line"><span class="comment">//                    false表示什么？</span></span><br><span class="line"><span class="comment">//                        a引用指向的对象不是Cat类型。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//   做向下转型之前，为了避免ClassCastException的发生，一般建议使用instanceof进行判断</span></span><br><span class="line">        System.out.println(x <span class="keyword">instanceof</span> Bird);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Bird) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;=========================&quot;</span>);</span><br><span class="line">            <span class="type">Bird</span> <span class="variable">y</span> <span class="operator">=</span> (Bird) x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3、多态有什么作用？"><a href="#2-3、多态有什么作用？" class="headerlink" title="2.3、多态有什么作用？"></a>2.3、多态有什么作用？</h3><p>通过 instanceof 运算符可以在程序运行时动态确定对象的类型，根据不同的情况做出相应的处理。<br>这使得程序具有更强的适应性和灵活性，可以根据实际情况采取不同的行动，而不需要在编码时就确定对象的具体类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop19;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 多态</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        a.eat();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求：程序运行阶段动态确定对象</span></span><br><span class="line">        <span class="comment">// 如果对象是Cat，请抓老鼠。</span></span><br><span class="line">        <span class="comment">// 如果对象是Bird，请唱歌。</span></span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">            <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) a;</span><br><span class="line">            cat.catchMouse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Bird) &#123;</span><br><span class="line">            <span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> (Bird) a;</span><br><span class="line">            bird.sing();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、开闭原则（OCP）————使用多态实现OCP原则"><a href="#三、开闭原则（OCP）————使用多态实现OCP原则" class="headerlink" title="三、开闭原则（OCP）————使用多态实现OCP原则"></a>三、开闭原则（OCP）————使用多态实现OCP原则</h2><p><strong>开放-封闭原则（Open-Closed Principle，OCP）：</strong><br>软件实体（类、模块、函数等）应该<strong>对扩展开放</strong>，<strong>对修改关闭</strong>。这意味着当需要改变系统的行为时，应该尽量通过扩展而不是修改现有的代码来实现。   </p><h3 id="3-1、-未使用多态"><a href="#3-1、-未使用多态" class="headerlink" title="3.1、 未使用多态"></a>3.1、 未使用多态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop20;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 宠物猫</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop20;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗狗啃骨头！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop20;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主人类</span></span><br><span class="line"><span class="comment"> * 开始业务是喂猫，但是后面业务改变要喂狗了，在没有使用多态的情况下就必须要改变Master，不符合OCP。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Master</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat c)</span> &#123;</span><br><span class="line">        c.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog d)</span>&#123;</span><br><span class="line">        d.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">package</span> com.camellia.oop20;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个案例没有使用多态机制，看看设计上有什么缺陷？</span></span><br><span class="line"><span class="comment"> *      不符合OCP。不符合开闭原则。（因为这个功能的扩展是建立在修改Master类的基础之上的。）</span></span><br><span class="line"><span class="comment"> *      OCP倡导的是什么？进行功能扩展的时候，最好不要修改原有代码，最好是以新增代码来完成扩展。</span></span><br><span class="line"><span class="comment"> *      对修改关闭。对扩展开放。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建宠物猫对象</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">// 创建主人对象</span></span><br><span class="line">        <span class="type">Master</span> <span class="variable">master</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Master</span>();</span><br><span class="line">        <span class="comment">// 主人喂猫</span></span><br><span class="line">        master.feed(c);</span><br><span class="line">        master.feed(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2、使用多态"><a href="#3-2、使用多态" class="headerlink" title="3.2、使用多态"></a>3.2、使用多态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop21;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 宠物类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop21;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Pet</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop21;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Pet</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗狗在啃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop21;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Master</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Pet p)</span>&#123;   <span class="comment">//这里就是用多态，父类引用指向子类，提高扩展性。</span></span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop21;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 还是主人喂养宠物的案例，使用多态机制，达到OCP原则。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 能用多态尽量使用多态。尽量面向抽象编程。不要面向具体编程。</span></span><br><span class="line"><span class="comment"> * 面向抽象编程的好处？降低耦合度，提高扩展力。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建宠物</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建主人</span></span><br><span class="line">        <span class="type">Master</span> <span class="variable">master</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Master</span>();</span><br><span class="line">        master.feed(c);</span><br><span class="line">        master.feed(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3、静态方法不存在方法覆盖"><a href="#3-3、静态方法不存在方法覆盖" class="headerlink" title="3.3、静态方法不存在方法覆盖"></a>3.3、静态方法不存在方法覆盖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop22;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal&#x27;s test method invoke&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop22;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试去重写父类的静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat&#x27;s test method invoke&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop22;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  方法覆盖针对的是实例方法。和静态方法无关。【方法的覆盖和多态机制联合起来才有意义。】</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Animal.test();</span><br><span class="line">        <span class="comment">//test是静态方法、可以通过类名调用和实例无关。</span></span><br><span class="line">        Cat.test();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        a.test();</span><br><span class="line">        <span class="comment">//虽然a指向的是Cat()对象，但是a是Animal类型的实例变量，所以此test是Animal的静态方法。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4、实例变量没有多态"><a href="#3-4、实例变量没有多态" class="headerlink" title="3.4、实例变量没有多态"></a>3.4、实例变量没有多态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop22;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法覆盖针对的是实例方法。和实例变量没有关系。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 多态</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="comment">// 实例变量不存在覆盖这一说。</span></span><br><span class="line">        <span class="comment">// a.name编译阶段绑定的是A类的name属性，运行的时候也会输出A类的name属性值。</span></span><br><span class="line">        System.out.println(a.name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有用多态</span></span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        System.out.println(b.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
          <category> Java Part_1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承</title>
      <link href="/2024/05/02/%E7%BB%A7%E6%89%BF/"/>
      <url>/2024/05/02/%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="一、继承的基本语法"><a href="#一、继承的基本语法" class="headerlink" title="一、继承的基本语法"></a>一、继承的基本语法</h2><p>1、<strong>继承概念：</strong> 在Java中，继承是面向对象编程中的一个重要概念，它允许一个类（称为子类或派生类）继承另一个类（称为父类或基类）的属性和方法。<br>Java中的继承通过关键字extends来实现。    </p><blockquote><ul><li>Java只支持单继承，一个类只能直接继承一个类。    </li><li>Java不支持多继承，但是支持多重继承。    </li><li>子类继承父类，除了<strong>私有的不支持继承</strong>、<strong>构造方法不支持继承</strong>，其他的全部都能继承。    </li><li>一个类没有显示的继承任何类，默认继承java.lang.Object类。</li><li>Object是老祖宗，是JDK类库中的根类。</li></ul></blockquote><p>2、<strong>继承在Java中的实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Subclass</span> <span class="keyword">extends</span> <span class="title class_">Superclass</span> &#123;</span><br><span class="line">    <span class="comment">// 子类的成员变量和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、<strong>继承的相关术语</strong>    </p><ul><li>父类也可以叫做超类、基类、superclass。   </li><li>子类也可叫做派生类、subclass。</li></ul><h2 id="二、方法覆盖-Override-方法重写-Overwrite"><a href="#二、方法覆盖-Override-方法重写-Overwrite" class="headerlink" title="二、方法覆盖&#x2F;Override&#x2F;方法重写&#x2F;Overwrite"></a>二、方法覆盖&#x2F;Override&#x2F;方法重写&#x2F;Overwrite</h2><ol><li>什么时候使用方法重写？<br>当从父类继承来的方法，无法满足子类业务需求时。</li><li>当满足什么条件的时候，构成方法重写？<ul><li>方法覆盖发生在具有继承关系的父子类之间。</li><li>具有相同的方法名（必须严格一样）</li><li>具有相同的形参列表（必须严格一样）</li><li>具有相同的返回值类型（可以是子类型）</li></ul></li><li>关于方法重写的细节<ul><li>当子类将父类方法覆盖之后，将来子类对象调用方法的时候，一定会执行重写之后的方法。</li><li>在java语言中，有一个注解，这个注解可以在编译阶段检查这个方法是否是重写了父类的方法。@Override注解是JDK5引入，用来标注方法，被标注的方法必须是重写父类的方法，如果不是重写的方法，编译器会报错。@Override注解只在编译阶段有用，和运行期无关。</li><li>如果返回值类型是引用数据类型，那么这个返回值类型可以是原类型的子类型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObj</span><span class="params">(<span class="type">int</span> a,String b)</span>&#123;</span><br><span class="line">        retrun;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getObj</span><span class="params">(<span class="type">int</span> a,String b)</span>&#123;   <span class="comment">//返回值String是Object的子类。            return ;</span></span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>当在子类中重写父类方法时，访问权限可以变得更高，但不能变得更低。这是因为子类中的方法必须能够访问父类中的方法，否则就会破坏继承关系。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 父类中的方法使用protected访问修饰符</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal makes a sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">     <span class="comment">// 子类中的方法将访问权限从protected提升为public</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>抛出异常不能变多，可以变少。（后面学习异常的时候再说。）</li><li>私有的方法，以及构造方法不能继承，因此他们不存在方法覆盖。</li><li>方法覆盖针对的是实例方法。和静态方法无关。（讲完多态再说。）</li><li>方法覆盖针对的是实例方法。和实例变量没有关系。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
          <category> Java Part_1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式（基础介绍）</title>
      <link href="/2024/05/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D%EF%BC%89/"/>
      <url>/2024/05/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>&#x3D;&#x3D;<strong>实现单例模式的步骤</strong>&#x3D;&#x3D;   </p><ol><li>私有化构造方法<br>确保外部不能直接通过构造方法来实例化对象，从而限制对象的创建。</li><li>提供静态方法获取实例<br>通过一个静态方法来获取单例对象的实例，通常命名为 getInstance()。</li><li>提供一个静态变量（对于饿汉和懒汉不同）</li></ol><h2 id="一、饿汉式单例模式"><a href="#一、饿汉式单例模式" class="headerlink" title="一、饿汉式单例模式"></a>一、饿汉式单例模式</h2><ol><li>私有化构造方法<br>确保外部不能直接通过构造方法来实例化对象，从而限制对象的创建。</li><li>提供静态方法获取实例<br>通过一个静态方法来获取单例对象的实例，通常命名为 getInstance()。</li><li>定义一个静态变量<br>在类加载的时候，初始化静态变量。（只初始化一次）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.singleton1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//饿汉式单例模式：类加载时对象就创建好了。不管这个对象用还是不用。提前先把对象创建好。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.singleton1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance1</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance1 == instance2);   <span class="comment">//比较引用存储的对象地址。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、懒汉式单例模式"><a href="#二、懒汉式单例模式" class="headerlink" title="二、懒汉式单例模式"></a>二、懒汉式单例模式</h2><ol><li>私有化构造方法<br>确保外部不能直接通过构造方法来实例化对象，从而限制对象的创建。</li><li>提供静态方法获取实例<br>通过一个静态方法来获取单例对象的实例，通常命名为 getInstance()。</li><li>定义一个静态变量<br>但是这个变量值为null。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.singleton2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.singleton2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance1</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance1 == instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
          <category> Java Part_1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类</title>
      <link href="/2024/04/30/%E7%B1%BB/"/>
      <url>/2024/04/30/%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="一、类的定义"><a href="#一、类的定义" class="headerlink" title="一、类的定义"></a>一、类的定义</h2><p>在计算机编程中，类（Class）是一种抽象数据类型（ADT），它是面向对象编程（OOP）的基本概念之一。类是对现实世界中对象的抽象，它定义了对象的属性（成员变量）和行为（成员方法）。</p><p><strong>类的定义通常包括以下几个要素：</strong></p><ol><li><p><strong>类名（Class Name）</strong>：类的名称用于标识该类，在代码中可以通过类名来引用该类。类名通常使用大驼峰命名法（Pascal Case）。</p></li><li><p><strong>成员变量（Member Variables）</strong>：也称为属性或字段（Fields），用于描述类的状态或特征。成员变量可以是各种数据类型（如整数、浮点数、字符串等），它们代表了对象的各种属性。在类的定义中，成员变量通常以变量名和数据类型的形式列出。</p></li><li><p><strong>成员方法（Member Methods）</strong>：也称为函数或操作（Methods），用于描述类的行为或功能。成员方法定义了对象可以执行的操作，它们可以操作对象的状态，并且可以被外部代码调用以执行特定的任务。在类的定义中，成员方法通常以方法名、参数列表和返回类型的形式列出。</p></li><li><p><strong>构造方法（Constructor）</strong>：是一种特殊类型的成员方法，用于在创建对象时初始化对象的状态。构造方法的名称与类名相同，并且通常没有返回类型。在Java等编程语言中，通过调用构造方法可以创建类的实例。</p></li><li><p><strong>访问修饰符（Access Modifiers）</strong>：用于控制类的成员对外部代码的可见性和访问权限。常见的访问修饰符包括public、protected、private等。</p></li></ol><p>一个简单的类定义示例（使用Java语言）如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> myNumber;</span><br><span class="line">    <span class="keyword">private</span> String myString;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(<span class="type">int</span> number, String str)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myNumber = number;</span><br><span class="line">        <span class="built_in">this</span>.myString = str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printDetails</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Number: &quot;</span> + myNumber);</span><br><span class="line">        System.out.println(<span class="string">&quot;String: &quot;</span> + myString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 在这个示例中，类名为MyClass，包含了两个成员变量（myNumber和myString）、一个构造方法（MyClass）和一个成员方法（printDetails）。</span></span><br><span class="line"><span class="comment"> 这个类定义了一个简单的数据结构，表示了一个具有整数和字符串属性的对象，并且提供了一个方法用于打印对象的属性。       </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="二、类对象的创建和使用"><a href="#二、类对象的创建和使用" class="headerlink" title="二、类对象的创建和使用"></a>二、类对象的创建和使用</h2><p>创建和使用类对象是面向对象编程中的基本操作，它们使我们能够使用类定义的属性和方法来操作对象。</p><p><strong>以下是创建和使用类对象的一般步骤：</strong></p><ol><li><strong>类定义</strong>：首先，我们需要定义一个类，其中包括类的属性（成员变量）和方法（成员方法）。</li><li><strong>对象实例化</strong>：在程序中，通过使用类的构造方法来创建类的实例（对象）。构造方法会初始化对象的状态，并返回一个指向该对象的引用。</li><li><strong>访问成员变量</strong>：一旦对象被创建，我们可以使用点操作符（<code>.</code>）来访问对象的成员变量，并为其赋值或获取值。</li><li><strong>调用成员方法</strong>：同样，我们也可以使用<strong>点操作符</strong>来调用对象的成员方法，并向方法传递参数（如果需要）。</li></ol><p>以下是一个简单的示例，演示了如何创建类对象并使用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> myNumber;</span><br><span class="line">    <span class="keyword">private</span> String myString;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(<span class="type">int</span> number, String str)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myNumber = number;</span><br><span class="line">        <span class="built_in">this</span>.myString = str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printDetails</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Number: &quot;</span> + myNumber);</span><br><span class="line">        System.out.println(<span class="string">&quot;String: &quot;</span> + myString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建类对象</span></span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>(<span class="number">10</span>, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 访问成员变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> obj.myNumber;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> obj.myString;</span><br><span class="line">        System.out.println(<span class="string">&quot;Number: &quot;</span> + number);</span><br><span class="line">        System.out.println(<span class="string">&quot;String: &quot;</span> + str);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用成员方法</span></span><br><span class="line">        obj.printDetails();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 在这个示例中，我们首先定义了一个名为MyClass的类，其中包含了一个构造方法（用于初始化对象的状态）和一个成员方法（用于打印对象的属性）。</span></span><br><span class="line"><span class="comment"> 然后，在Main类中，我们通过调用MyClass的构造方法创建了一个名为obj的对象。</span></span><br><span class="line"><span class="comment"> 接着，我们通过点操作符访问对象的成员变量，并调用对象的成员方法来操作对象。 </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="三、JVM内存分析"><a href="#三、JVM内存分析" class="headerlink" title="三、JVM内存分析"></a>三、JVM内存分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop01;</span><br><span class="line"><span class="comment">/*实例变量属于成员变量，成员变量如果没有手动赋值，系统会赋默认值</span></span><br><span class="line"><span class="comment">    数据类型        默认值</span></span><br><span class="line"><span class="comment">    ----------------------</span></span><br><span class="line"><span class="comment">    byte            0</span></span><br><span class="line"><span class="comment">    short           0</span></span><br><span class="line"><span class="comment">    int             0</span></span><br><span class="line"><span class="comment">    long            0L</span></span><br><span class="line"><span class="comment">    float           0.0F</span></span><br><span class="line"><span class="comment">    double          0.0</span></span><br><span class="line"><span class="comment">    boolean         false</span></span><br><span class="line"><span class="comment">    char            \u0000</span></span><br><span class="line"><span class="comment">    引用数据类型      null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属性：姓名，年龄，性别，他们都是实例变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 性别</span></span><br><span class="line">    <span class="type">boolean</span> gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 局部变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过学生类Student实例化学生对象</span></span><br><span class="line"></span><br><span class="line">（通过类创造对象）</span><br><span class="line">        <span class="comment">// Student s1; 是什么？s1是变量名。Student是一种数据类型名。属于引用数据类型。</span></span><br><span class="line">        <span class="comment">// s1也是局部变量。和i一样。</span></span><br><span class="line">        <span class="comment">// s1变量中保存的是：堆内存中Student对象的内存地址。</span></span><br><span class="line">        <span class="comment">// s1有一个特殊的称呼：引用</span></span><br><span class="line">        <span class="comment">// 什么是引用？引用的本质上是一个变量，这个变量中保存了java对象的内存地址。</span></span><br><span class="line">        <span class="comment">// 引用和对象要区分开。对象在JVM堆当中。引用是保存对象地址的变量。</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问对象的属性（读变量的值）</span></span><br><span class="line">        <span class="comment">// 访问实例变量的语法：引用.变量名</span></span><br><span class="line">        <span class="comment">// 两种访问方式：第一种读取，第二种修改。</span></span><br><span class="line">        <span class="comment">// 读取：引用.变量名 s1.name; s1.age; s1.gender;</span></span><br><span class="line">        <span class="comment">// 修改：引用.变量名 = 值; s1.name = &quot;jack&quot;; s1.age = 20; s1.gender = true;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + s1.name); <span class="comment">// null</span></span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span> + s1.age); <span class="comment">// 0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;性别：&quot;</span> + (s1.gender ? <span class="string">&quot;男&quot;</span> : <span class="string">&quot;女&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改对象的属性（修改变量的值，给变量重新赋值）</span></span><br><span class="line">        s1.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        s1.age = <span class="number">20</span>;</span><br><span class="line">        s1.gender = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + s1.name); <span class="comment">// 张三</span></span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span> + s1.age); <span class="comment">// 20</span></span><br><span class="line">        System.out.println(<span class="string">&quot;性别：&quot;</span> + (s1.gender ? <span class="string">&quot;男&quot;</span> : <span class="string">&quot;女&quot;</span>)); <span class="comment">// 男</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再创建一个新对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问对象的属性</span></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名=&quot;</span> + s2.name); <span class="comment">// null</span></span><br><span class="line">        System.out.println(<span class="string">&quot;年龄=&quot;</span> + s2.age); <span class="comment">// 0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;性别=&quot;</span> + (s2.gender ? <span class="string">&quot;男&quot;</span> : <span class="string">&quot;女&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改对象的属性</span></span><br><span class="line">        s2.name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">        s2.age = <span class="number">20</span>;</span><br><span class="line">        s2.gender = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名=&quot;</span> + s2.name); <span class="comment">// 李四</span></span><br><span class="line">        System.out.println(<span class="string">&quot;年龄=&quot;</span> + s2.age); <span class="comment">// 20</span></span><br><span class="line">        System.out.println(<span class="string">&quot;性别=&quot;</span> + (s2.gender ? <span class="string">&quot;男&quot;</span> : <span class="string">&quot;女&quot;</span>)); <span class="comment">// 女</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/asserts_JavaSE/202405011253305.png" alt="JVM内存分析图"></p><p>从此图可以看出，开始将所有类的字节码存储到元空间当中，当对象被创建时就在堆内存中开辟一个空间，用于存储对象和实例变量等。然后通过引用实现对对象的一系列操作。<br>其中对象属性等的改变都发生在堆内存中，引用只不过保存了它的地址（这和C++中的指针很像）。</p><h2 id="四、实例变量和实例方法的访问"><a href="#四、实例变量和实例方法的访问" class="headerlink" title="四、实例变量和实例方法的访问"></a>四、实例变量和实例方法的访问</h2><ol><li>实例变量要想访问，必须先new对象。通过引用来访问实例变量。    </li><li>实例变量是不能通过类名直接访问的。</li><li>我们通常描述一个对象的行为动作时，不加static。 没有添加static的方法，被叫做：实例方法。（对象方法）</li><li>空指针异常：一个空引用访问实例相关的，都会出现空指针异常。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    </span><br><span class="line">    String name; <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="comment">// 出生日期</span></span><br><span class="line">    String birth;</span><br><span class="line">    <span class="comment">// 性别</span></span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法：行为动作</span></span><br><span class="line">    <span class="comment">// 吃</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123; <span class="comment">// 实例方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;宠物在吃东西&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;宠物在跑步&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PetTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建宠物对象</span></span><br><span class="line">        <span class="type">Pet</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pet</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给属性赋值</span></span><br><span class="line">        dog.name = <span class="string">&quot;小黑&quot;</span>;</span><br><span class="line">        dog.birth = <span class="string">&quot;2012-10-11&quot;</span>;</span><br><span class="line">        dog.sex = <span class="string">&#x27;雄&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取属性的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;狗狗的名字：&quot;</span> + dog.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;狗狗的生日：&quot;</span> + dog.birth);</span><br><span class="line">        System.out.println(<span class="string">&quot;狗狗的性别：&quot;</span> + dog.sex);</span><br><span class="line"></span><br><span class="line">        dog = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：引用一旦为null，表示引用不再指向对象了。但是通过引用访问name属性，编译可以通过。</span></span><br><span class="line">        <span class="comment">// 运行时会出现异常：空指针异常。NullPointerException。这是一个非常著名的异常。</span></span><br><span class="line">        <span class="comment">// 为什么会出现空指针异常？因为运行的时候会找真正的对象，如果对象不存在了，就会出现这个异常。</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;狗狗的名字：&quot; + dog.name);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 会出现空指针异常。</span></span><br><span class="line">        dog.eat();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 会出现空指针异常。</span></span><br><span class="line">        <span class="comment">//dog.run();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.lang.NullPointerException</span></span><br></pre></td></tr></table></figure><blockquote><p>如果没有任何引用指向对象，该对象最终会被当做垃圾被GC回收。</p></blockquote></li></ol><h2 id="五、方法调用时传递参数"><a href="#五、方法调用时传递参数" class="headerlink" title="五、方法调用时传递参数"></a>五、方法调用时传递参数</h2><h3 id="5-1、方法调用时传递基本数据类型"><a href="#5-1、方法调用时传递基本数据类型" class="headerlink" title="5.1、方法调用时传递基本数据类型"></a>5.1、方法调用时传递基本数据类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题：判断该程序的输出结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArgsTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 调用add方法的时候，将i传进去，实际上是怎么传的？将i变量中保存值10复制了一份，传给了add方法。</span></span><br><span class="line">        add(i);</span><br><span class="line">        System.out.println(<span class="string">&quot;main---&gt;&quot;</span> + i); <span class="comment">// 10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 方法的形参是局部变量。</span></span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(<span class="string">&quot;add---&gt;&quot;</span> + i); <span class="comment">// 11</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/asserts_JavaSE/202405011253714.png" alt="在这里插入图片描述"></p><h3 id="5-2、方法调用时传递引用数据类型"><a href="#5-2、方法调用时传递引用数据类型" class="headerlink" title="5.2、方法调用时传递引用数据类型"></a>5.2、方法调用时传递引用数据类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop04;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题：分析以下程序输出结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArgsTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        u.age = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// u是怎么传递过去的。实际上和i原理相同：都是将变量中保存的值传递过去。</span></span><br><span class="line">        <span class="comment">// 只不过这里的u变量中保存的值比较特殊，是一个对象的内存地址。</span></span><br><span class="line">        add(u);</span><br><span class="line">        System.out.println(<span class="string">&quot;main--&gt;&quot;</span> + u.age); <span class="comment">// 11</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(User u)</span> &#123; <span class="comment">// u是一个引用。</span></span><br><span class="line">        u.age++;</span><br><span class="line">        System.out.println(<span class="string">&quot;add--&gt;&quot;</span> + u.age); <span class="comment">// 11</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个和基本数据类型原理相同。首先明确引用数据类型中应用存储的是User的地址，所以add(User u);实质上是将main中的引用u里存储的值（就是new User();的地址）复制一份给add方法。</p></blockquote><h2 id="六、封装"><a href="#六、封装" class="headerlink" title="* 六、封装"></a>* 六、封装</h2><p><strong>概念：</strong> 封装是面向对象编程中的一个重要概念，它指的是将数据和操作数据的方法捆绑在一起，并限制对数据的访问。<br>         封装的目的是隐藏对象的内部细节，只向外界暴露必要的接口，以防止外部代码直接访问对象的内部状态，从而提高代码的安全性和可维护性。<br><strong>如何实现封装：</strong><br><strong>数据隐藏（Data Hiding）：</strong> 封装通过将对象的数据隐藏起来即属性私有化，只允许通过对象的方法来访问和修改数据，从而防止外部直接访问对象的内部状态。<br><strong>访问控制（Access Control）：</strong> 通常，封装会将对象的属性设置为私有（private），只允许通过公共（public）方法来访问和修改这些属性。    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop07;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为了保证User类型对象的age属性的安全，我们需要使用封装机制。实现封装的步骤是什么？</span></span><br><span class="line"><span class="comment"> *      第一步：属性私有化。(什么是私有化？使用 private 进行修饰。)</span></span><br><span class="line"><span class="comment"> *      属性私有化的作用是：禁止外部程序对该属性进行随意的访问。</span></span><br><span class="line"><span class="comment"> *      所有被private修饰的，都是私有的，私有的只能在本类中访问。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      第二步：对外提供setter和getter方法。</span></span><br><span class="line"><span class="comment"> *      为了保证外部的程序仍然可以访问age属性，因此要对外提供公开的访问入口。</span></span><br><span class="line"><span class="comment"> *      访问一般包括两种：</span></span><br><span class="line"><span class="comment"> *          读：读取属性的值</span></span><br><span class="line"><span class="comment"> *          改：修改属性的值</span></span><br><span class="line"><span class="comment"> *      那么应该对外提供两个方法，一个负责读，一个负责修改。</span></span><br><span class="line"><span class="comment"> *      读方法的格式：getter</span></span><br><span class="line"><span class="comment"> *          public int getAge()&#123;&#125;</span></span><br><span class="line"><span class="comment"> *      改方法的格式：setter</span></span><br><span class="line"><span class="comment"> *          public void setAge(int age)&#123;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取age属性的值</span></span><br><span class="line">    <span class="comment">// getter方法是绝对安全的。因为这个方法是读取属性的值，不会涉及修改操作。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//return this.age;</span></span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改age属性的值</span></span><br><span class="line">    <span class="comment">// setter方法当中就需要编写拦截过滤代码，来保证属性的安全。</span></span><br><span class="line">    <span class="comment">// java有就近原则，若不加this关键字都默认是形参age。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(age &lt; <span class="number">0</span> || age &gt; <span class="number">100</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对不起，您的年龄值不合法！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// this. 大部分情况下可以省略。</span></span><br><span class="line">        <span class="comment">// this. 什么时候不能省略？用来区分局部变量和实例变量的时候。</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop07;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="comment">// 读</span></span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span> + u.getAge());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 改</span></span><br><span class="line">        u.setAge(-<span class="number">100</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读</span></span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span> + u.getAge());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//改</span></span><br><span class="line">        u.setAge(<span class="number">50</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//读</span></span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span> + u.getAge()); <span class="comment">// 50</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、构造方法"><a href="#七、构造方法" class="headerlink" title="* 七、构造方法"></a>* 七、构造方法</h2><h3 id="7-1、构造方法的基本知识点"><a href="#7-1、构造方法的基本知识点" class="headerlink" title="7.1、构造方法的基本知识点"></a>7.1、构造方法的基本知识点</h3><h4 id="1、构造方法的作用"><a href="#1、构造方法的作用" class="headerlink" title="1、构造方法的作用"></a>1、构造方法的作用</h4><p><strong>对象的创建：</strong> 构造方法通过调用完成对象的创建。当使用 new 关键字实例化一个对象时，构造方法被调用，对象在内存中被创建并分配空间。<br><strong>对象的初始化：</strong> 构造方法用于给对象的所有属性赋值，即对象的初始化。它确保对象在创建后处于一个合适的状态，属性被赋予初始值，以便对象可以正常运行。   </p><h4 id="2、定义构造方法的方式"><a href="#2、定义构造方法的方式" class="headerlink" title="2、定义构造方法的方式"></a>2、定义构造方法的方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符列表] 构造方法名(形参列表) &#123;</span><br><span class="line">构造方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong>    </p><ul><li>构造方法名必须和类名一致，以便编译器能够识别并与类关联。    </li><li>构造方法不需要提供返回值类型，因为它的主要目的是创建对象，而不是返回值。    </li><li>如果提供了返回值类型，则该方法不再是构造方法，而是普通方法，不能用于对象的创建。</li></ul><h4 id="3、构造方法怎么调用呢？"><a href="#3、构造方法怎么调用呢？" class="headerlink" title="3、构造方法怎么调用呢？"></a>3、构造方法怎么调用呢？</h4><ul><li>使用new运算符来调用。</li><li>语法：new 构造方法名(实参);</li><li>注意：构造方法最终执行结束之后，会自动将创建的对象的内存地址返回。但构造方法体中不需要提供“return 值;”这样的语句。</li></ul><h4 id="4、构造方法相关注意事项"><a href="#4、构造方法相关注意事项" class="headerlink" title="4、构造方法相关注意事项"></a>4、构造方法相关注意事项</h4><ul><li>在Java语言中，如果一个类没有显式定义构造方法，系统会默认提供一个无参数的构造方法。这个构造方法通常称为缺省构造器。</li><li>如果一个类显式定义了构造方法，系统则不再提供缺省构造器。因此，为了对象创建更加方便，建议手动编写一个无参数的构造方法。</li><li>在Java中，一个类可以定义多个构造方法，并且这些构造方法自动构成了方法的重载。这意味着可以根据不同的参数列表调用不同的构造方法来创建对象。</li><li>构造方法中给属性赋值是对象第一次创建时属性的初始值。然而，单独定义set方法给属性赋值的好处在于后期可以灵活地修改属性的值。这种方式允许在对象创建后，根据需要修改对象的属性，从而增加了对象的灵活性和可维护性。</li></ul><h4 id="5、构造方法的执行原理"><a href="#5、构造方法的执行原理" class="headerlink" title="5、构造方法的执行原理"></a>5、构造方法的执行原理</h4><ul><li><p>构造方法的执行包括两个重要的阶段：</p><ul><li>第一阶段：对象的创建</li><li>第二阶段：对象的初始化</li></ul></li><li><p>对象在什么时候创建的？</p><ul><li>当使用<code>new</code>关键字实例化一个对象时，在堆内存中直接开辟空间。这个过程中，会给对象的所有属性<strong>赋默认值</strong>，完成对象的创建。这一过程发生在构造方法体执行之前。</li></ul></li><li><p>对象初始化在什么时候完成的？</p><ul><li>构造方法体开始执行时，标志着对象的初始化过程开始。在构造方法体中，可以对对象的属性进行赋值等初始化操作。构造方法体执行完毕，表示对象初始化完毕。此时，对象处于可用状态，可以被程序进一步操作和调用。</li></ul></li></ul><h4 id="6、构造代码块"><a href="#6、构造代码块" class="headerlink" title="6、构造代码块"></a>6、构造代码块</h4><ul><li><p><strong>语法格式：</strong></p><ul><li>构造代码块的语法格式为一对大括号<code>&#123;&#125;</code>，没有参数列表。</li></ul></li><li><p><strong>执行时机及次数：</strong></p><ul><li>每次在使用<code>new</code>关键字创建对象时，构造代码块都会被执行。</li><li>构造代码块是在构造方法执行之前执行的，因此在对象的初始化过程中，构造代码块是首先被执行的。    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造代码块被执行&quot;</span>);</span><br><span class="line">        x = <span class="number">5</span>;</span><br><span class="line">        y = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Example</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取x的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取y的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getY</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">Example</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">        <span class="comment">// 输出属性值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;x 的值为：&quot;</span> + obj.getX());</span><br><span class="line">        System.out.println(<span class="string">&quot;y 的值为：&quot;</span> + obj.getY());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="7、构造代码块的作用"><a href="#7、构造代码块的作用" class="headerlink" title="7、构造代码块的作用"></a>7、构造代码块的作用</h4><p>构造代码块可以用于将对象初始化时共享的代码抽取出来，实现代码的复用。具体而言：</p><ul><li>如果所有的构造方法在最开始的时候有相同的一部分代码，可以将这部分代码放入构造代码块中。</li><li>构造代码块会在每次对象创建时都执行，确保共享的代码被执行，并且避免了代码重复。<br>这样，通过构造代码块，可以提高代码的可维护性和可读性，减少代码冗余，提高代码复用性。</li></ul><h2 id="八、this关键字"><a href="#八、this关键字" class="headerlink" title="*八、this关键字"></a>*八、this关键字</h2><p>this 本质上是一个引用。this 中保存的是当前对象的内存地址。<br>在Java中，<code>this</code> 是一个关键字，用于引用当前对象的实例。它通常用于区分实例变量和方法参数之间的命名冲突，或者在一个类的方法内部调用同一个类的另一个方法。下面详细解释 <code>this</code> 的几个常见用途：</p><ol><li><p><strong>区分实例变量和方法参数</strong>：当方法参数的名称与实例变量的名称相同时，使用 <code>this</code> 来引用当前对象的实例变量。这样可以明确指示要访问的是实例变量而不是方法参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;   <span class="comment">//这个形参与属性value相同，若不加this则根据Java中的就近原则，方法中的value都是形参value。</span></span><br><span class="line">        <span class="built_in">this</span>.value = value; <span class="comment">// 使用 this 引用实例变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>this.value</code> 指的是当前对象的 <code>value</code> 实例变量，而 <code>value</code> 是方法的参数。</p></li><li><p><strong>在构造器中调用另一个构造器</strong>：可以使用 <code>this</code> 调用<strong>同一个类</strong>的另一个构造器，且只能出现在第一行。这种方法通常被称为<strong>构造器重载</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//new MyClass(10,&quot;giaogiao&quot;);  这么会创建一个新对象</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="number">10</span>,<span class="string">&quot;giaogiao&quot;</span>);<span class="comment">// 调用另一个构造器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*这个的目的是什么？</span></span><br><span class="line"><span class="comment">          当要求类在初始化时，给它赋指定的默认值。</span></span><br><span class="line"><span class="comment">          EG：this.value=10;</span></span><br><span class="line"><span class="comment">              this.name=&quot;giaogiao&quot;;</span></span><br><span class="line"><span class="comment">          这段代码其实是重复的。而通过this(10,&quot;giaogiao&quot;);获取当前对象，调用MyClass(int value,String name)构造器以简化开发。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(<span class="type">int</span> value,String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，无参构造器调用了带参构造器，以避免重复代码。</p></li><li><p><strong>传递当前对象的引用</strong>：可以将当前对象的引用传递给其他方法，这在某些情况下很有用。</p></li></ol><p><img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/asserts_JavaSE/202405011254685.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop6;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="comment">// 私有成员变量 name</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 带参构造方法，用于初始化 name</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 无参构造方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取学生姓名的方法</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置学生姓名的方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 学习方法，打印当前对象的引用地址</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;study----&gt;&quot;</span> + <span class="built_in">this</span>);  <span class="comment">// 验证this是当前对象的引用。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop6;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建学生对象s1，初始化姓名为&quot;小吴&quot;</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小吴&quot;</span>);</span><br><span class="line">    <span class="comment">// 打印s1对象的引用地址</span></span><br><span class="line">    System.out.println(<span class="string">&quot;main----&gt;&quot;</span> + s1);</span><br><span class="line">    <span class="comment">// 调用s1对象的study()方法</span></span><br><span class="line">    s1.study();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建学生对象s2，初始化姓名为&quot;小花&quot;</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小花&quot;</span>);</span><br><span class="line">    <span class="comment">// 打印s2对象的引用地址</span></span><br><span class="line">    System.out.println(<span class="string">&quot;main----&gt;&quot;</span> + s2);</span><br><span class="line">    <span class="comment">// 调用s2对象的study()方法</span></span><br><span class="line">    s2.study();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>在Java中，当对象调用自己的方法时，方法体内的 this 关键字会引用该对象的实例。<br>在方法被调用时，Java虚拟机会隐式地将当前对象的引用传递给方法，以便方法能够访问对象的成员变量和方法。<br>因此，在普通方法中通过 this 关键字引用的就是调用该方法的当前对象。</p></blockquote><h2 id="九、static关键字"><a href="#九、static关键字" class="headerlink" title="九、static关键字"></a>九、static关键字</h2><p>在Java中，使用static关键字声明的成员（变量、方法、代码块）是类级别的，而不是与类的每个实例相关联的。<br>因此，它们可以通过类名直接访问，而无需创建类的实例。</p><h3 id="9-1、静态变量存储图"><a href="#9-1、静态变量存储图" class="headerlink" title="9.1、静态变量存储图"></a>9.1、静态变量存储图</h3><p>   1、没使用静态变量是的存储图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop7;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">//用户id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="comment">//用户国籍</span></span><br><span class="line">    <span class="keyword">private</span> String country=<span class="string">&quot;China&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ID: &quot;</span> + id+<span class="string">&quot;\tCountry: &quot;</span> + country);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop7;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;1001&quot;</span>);</span><br><span class="line">        user1.PrintInfo();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;1002&quot;</span>);</span><br><span class="line">        user2.PrintInfo();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;1003&quot;</span>);</span><br><span class="line">        user3.PrintInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/asserts_JavaSE/202405011255258.png"></p><p>2、使用静态变量时的存储图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">//用户id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="comment">//用户国籍</span></span><br><span class="line">    <span class="comment">//静态变量什么时候开劈空间（初始化）、存储在哪里？</span></span><br><span class="line">    <span class="comment">//类加载时初始化</span></span><br><span class="line">    <span class="comment">//JDK8之后：静态变量存储在堆内存之中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String country=<span class="string">&quot;China&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ID: &quot;</span> + id+<span class="string">&quot;\tCountry: &quot;</span> + country);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.camellia.oop8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.camellia.oop7.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        com.camellia.oop7.<span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.camellia.oop7.User(<span class="string">&quot;1001&quot;</span>);</span><br><span class="line">        user1.PrintInfo();</span><br><span class="line">        com.camellia.oop7.<span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.camellia.oop7.User(<span class="string">&quot;1002&quot;</span>);</span><br><span class="line">        user2.PrintInfo();</span><br><span class="line">        com.camellia.oop7.<span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;1003&quot;</span>);</span><br><span class="line">        user3.PrintInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/asserts_JavaSE/202405011255359.png"></p><h3 id="9-2、Java中静态变量和方法的访问，以及静态变量不能使用this关键字"><a href="#9-2、Java中静态变量和方法的访问，以及静态变量不能使用this关键字" class="headerlink" title="9.2、Java中静态变量和方法的访问，以及静态变量不能使用this关键字"></a>9.2、Java中静态变量和方法的访问，以及静态变量不能使用this关键字</h3><ol><li>静态变量和方法建议使用<code>类名.</code>调用。虽然用<code>引用.</code>也可以，但是实质还是通过类来调用，而且这样容易和实例变量和方法的访问相混淆。    </li><li>静态方法不能使用 this 关键字是因为 this 关键字代表当前对象的实例，而静态方法是与类相关联的，不依赖于任何特定的实例。所以无法直接访问实例变量和方法。</li></ol><h3 id="9-3、静态代码块"><a href="#9-3、静态代码块" class="headerlink" title="9.3、静态代码块"></a>9.3、静态代码块</h3><p>静态代码块是使用 <code>static</code> 关键字声明的代码块，它在类被加载时执行，并且只执行一次。<br>静态代码块通常用于在类加载时进行初始化操作，例如初始化静态变量或执行静态方法。它们的执行顺序是在类加载时按照代码顺序执行。</p><p><strong>静态代码块的特点包括：</strong></p><ol><li><p><strong>使用 <code>static</code> 关键字声明</strong>：静态代码块使用 <code>static</code> 关键字进行声明，以标识它们是与类相关联的，而不是与类的实例相关联的。</p></li><li><p><strong>在类加载时执行</strong>：静态代码块在类被加载时执行，并且只执行一次。类的加载是指当 JVM 第一次加载类时发生的操作，通常在首次创建类的实例之前。</p></li><li><p><strong>仅执行一次</strong>：静态代码块只会在类加载时执行一次，即使没有创建类的实例也会执行。</p></li></ol><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest01</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123; </span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;zhangsan&quot;</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 报错原因：在静态上下文中无法直接访问实例相关的数据。</span></span><br><span class="line">        <span class="comment">//System.out.println(name);</span></span><br><span class="line">        <span class="comment">// 这个i可以访问，是因为i变量是静态变量，正好也是在类加载时初始化。</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块1执行了&quot;</span>);</span><br><span class="line">        <span class="comment">// j无法访问的原因是：程序执行到这里的时候，j变量不存在。</span></span><br><span class="line">        <span class="comment">//System.out.println(j);</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;xxxx-xx-xx xx:xx:xx 000 -&gt; StaticTest01.class完成了类加载！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块2执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main execute!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块3执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态代码的执行顺序只能靠编写顺序的来确定，编写时在前的也就先执行。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
          <category> Java Part_1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Method（方法）</title>
      <link href="/2024/04/27/Method%EF%BC%88%E6%96%B9%E6%B3%95%EF%BC%89/"/>
      <url>/2024/04/27/Method%EF%BC%88%E6%96%B9%E6%B3%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Method-方法"><a href="#Method-方法" class="headerlink" title="Method (方法)"></a>Method (方法)</h1><h2 id="一、静态方法什么时候需要用类名调用？"><a href="#一、静态方法什么时候需要用类名调用？" class="headerlink" title="一、静态方法什么时候需要用类名调用？"></a>一、静态方法什么时候需要用类名调用？</h2><p>调用者和被调用者在同一个类中时，可以省略。    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用方法是，类名. 什么情况下可以省略。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//调用method1</span></span><br><span class="line">        method1();</span><br><span class="line">        MethodTest01.method1();</span><br><span class="line">        <span class="comment">//调用method2</span></span><br><span class="line">        <span class="comment">/*method2(); 编译器报错*/</span></span><br><span class="line">        MethodTest.method2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;mothod1执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">MethodTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method2执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、方法语法的小细节"><a href="#二、方法语法的小细节" class="headerlink" title="二、方法语法的小细节"></a>二、方法语法的小细节</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest05</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缺少返回语句</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">99</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//虽然这里有返回语句，但是有几率不执行if语句。所以编译器不通过。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、方法执行的内存图"><a href="#三、方法执行的内存图" class="headerlink" title="三、方法执行的内存图"></a>三、方法执行的内存图</h2><blockquote><p><strong>概念：</strong> Java 的元空间（Metaspace）是 Java 虚拟机（JVM）用来存储类元数据的内存区域。在传统的 Java 虚拟机实现中，类元数据通常存储在永久代（Permanent Generation）中。但是，从 JDK 8 开始，永久代被移除，取而代之的是元空间。 </p><p><strong>元空间与永久代相比有几个显著的不同点：</strong></p><ul><li>内存位置： 元空间不是在 Java 虚拟机的堆内存中，而是位于本地内存中。这使得元空间的大小不受堆内存的限制，可以动态地根据应用程序的需要调整大小。</li><li>自动调整大小： 元空间的大小可以根据应用程序的需要动态调整，因此不容易出现类加载溢出的情况。在使用元空间时，不需要手动设置元空间的大小，JVM 会根据应用程序的需求自动调整。</li><li>内存回收： 元空间的内存是由 JVM 进行管理的，不需要像永久代一样手动进行垃圾回收。当类加载器不再需要某些类的元数据时，JVM 会自动进行回收，而不会出现永久代中的内存泄漏问题。</li><li>垃圾收集器： 元空间的垃圾收集与堆内存的垃圾收集不同，通常不会触发 Full GC。类加载器卸载类时，相关的元数据会被及时回收，不会等待垃圾收集器的触发。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.方法如果只定义，不调用是不会分配内存空间。（从Java8开始，方法的字节码指令存储在元空间metaspace当中。元空间使用的是本地内存。）</span></span><br><span class="line"><span class="comment">2.方法调用的瞬间，会在JVM的栈内存当中分配活动场所，此时发生压栈动作。</span></span><br><span class="line"><span class="comment">3.方法一旦结束，给该方法分配的内存空间就会释放。此时发生弹栈动作。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest02</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main begin&quot;</span>);</span><br><span class="line">        m1();</span><br><span class="line">        System.out.println(<span class="string">&quot;main over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1 begin&quot;</span>);</span><br><span class="line">        m2();</span><br><span class="line">        System.out.println(<span class="string">&quot;m1 over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m2 begin&quot;</span>);</span><br><span class="line">        m3();</span><br><span class="line">        System.out.println(<span class="string">&quot;m2 over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m3 begin&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;m3 over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/asserts_JavaSE/202405011253474.png"></p><h2 id="四、方法重载"><a href="#四、方法重载" class="headerlink" title="四、方法重载"></a>四、方法重载</h2><h3 id="4-1、在-Java-中，方法重载需要满足以下条件："><a href="#4-1、在-Java-中，方法重载需要满足以下条件：" class="headerlink" title="4.1、在 Java 中，方法重载需要满足以下条件："></a>4.1、在 Java 中，方法重载需要满足以下条件：</h3><ol><li><strong>方法名称相同：</strong> 重载方法的名称必须相同。</li><li><strong>参数列表不同：</strong> 重载方法的参数列表必须不同，可以通过参数的数量、类型或者顺序来区分不同的重载方法。</li><li><strong>返回类型可以不同：</strong> 重载方法的返回类型可以相同也可以不同。但是，仅仅通过返回类型的不同是无法实现方法重载的，因为 Java 中不允许仅通过返回类型的不同来区分不同的方法。</li><li><strong>访问修饰符、方法体、抛出的异常可以相同也可以不同：</strong> 重载方法的访问修饰符、方法体、以及方法中可能抛出的异常可以相同也可以不同。</li><li><strong>方法重载与参数的名称无关：</strong> 方法重载与参数的名称无关，只与参数列表的类型、数量和顺序有关。</li></ol><h3 id="4-2、方法重载示例代码"><a href="#4-2、方法重载示例代码" class="headerlink" title="4.2、方法重载示例代码"></a>4.2、方法重载示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法重载是编译阶段的机制还是运行阶段的机制？</span></span><br><span class="line"><span class="comment">方法重载机制是编译阶段的机制。</span></span><br><span class="line"><span class="comment">在编译阶段已经完成了方法的绑定。</span></span><br><span class="line"><span class="comment">在编译阶段已经确定了要调用哪个方法了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">什么情况下我们考虑使用方法重载呢？</span></span><br><span class="line"><span class="comment">在以后的开发中，在一个类中，如果两个方法的功能相似，建议将方法名定义为同一个名字。</span></span><br><span class="line"><span class="comment">此时就使用了方法重载机制。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodOverloadTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        m1();</span><br><span class="line">        m1</span><br><span class="line"></span><br><span class="line">(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        m2(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        m2(<span class="number">10L</span>, <span class="number">20L</span>);</span><br><span class="line"></span><br><span class="line">        m3(<span class="string">&quot;x&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        m3(<span class="number">10</span>, <span class="string">&quot;x&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 形参的个数不同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1(String s)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 形参类型不同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m2(int a, int b)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m2(long a, long b)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 形参顺序不同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">(String s, <span class="type">int</span> a)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m3(String s, int a)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">(<span class="type">int</span> a, String s)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m3(int a, String s)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下这两个方法没有构成方法重载，属于方法重复定义了。语法错误，编译器报错。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public static void doSome(int a, int b)&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">public static void doSome(int x, int y)&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3、println方法重载源码-部分"><a href="#4-3、println方法重载源码-部分" class="headerlink" title="4.3、println方法重载源码(部分)"></a>4.3、println方法重载源码(部分)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Methods that do not terminate lines */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 打印布尔值。 &#123;<span class="doctag">@link</span> 生成的字符串</span></span><br><span class="line"><span class="comment">    * java.lang.String#valueOf（boolean）&#125; 被转换为字节</span></span><br><span class="line"><span class="comment">    * 根据平台默认的字符编码，以及这些字节</span></span><br><span class="line"><span class="comment">    * 完全按照</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #write（int）&#125; 方法。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> b 要打印的 &#123;<span class="doctag">@code</span> 布尔值&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">       write(String.valueOf(b));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 打印字符。 该字符将转换为一个或多个字节</span></span><br><span class="line"><span class="comment">    * 根据给定给构造函数的字符编码，或</span></span><br><span class="line"><span class="comment">    * 平台的默认字符编码（如果未指定）。这些字节</span></span><br><span class="line"><span class="comment">    * 完全按照 &#123;<span class="doctag">@link</span> #write（int）&#125; 方法的方式编写。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> c 要打印的 &#123;<span class="doctag">@code</span> 字符&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">       write(String.valueOf(c));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 打印整数。 &#123;<span class="doctag">@link</span> 生成的字符串</span></span><br><span class="line"><span class="comment">    * java.lang.String#valueOf（int）&#125; 被转换为字节</span></span><br><span class="line"><span class="comment">    * 根据平台默认的字符编码，以及这些字节</span></span><br><span class="line"><span class="comment">    * 完全按照</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #write（int）&#125; 方法。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> i 要打印的 &#123;<span class="doctag">@code</span> int&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> java.lang.Integer#toString（int）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">       write(String.valueOf(i));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 打印长整数。 &#123;<span class="doctag">@link</span> 生成的字符串</span></span><br><span class="line"><span class="comment">    * java.lang.String#valueOf（long）&#125; 被翻译成字节</span></span><br><span class="line"><span class="comment">    * 根据平台默认的字符编码，以及这些字节</span></span><br><span class="line"><span class="comment">    * 完全按照</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #write（int）&#125; 方法。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> l 要打印的 &#123;<span class="doctag">@code</span> long&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> java.lang.Long#toString（long）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">long</span> l)</span> &#123;</span><br><span class="line">       write(String.valueOf(l));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 打印浮点数。 &#123;<span class="doctag">@link</span> 生成的字符串</span></span><br><span class="line"><span class="comment">    * java.lang.String#valueOf（float）&#125; 被转换为字节</span></span><br><span class="line"><span class="comment">    * 根据平台默认的字符编码，以及这些字节</span></span><br><span class="line"><span class="comment">    * 完全按照</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #write（int）&#125; 方法。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> f 要打印的 &#123;<span class="doctag">@code</span> float&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> java.lang.Float#toString（float）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">float</span> f)</span> &#123;</span><br><span class="line">       write(String.valueOf(f));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 打印双精度浮点数。 生成的字符串</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> java.lang.String#valueOf（double）&#125; 被翻译成</span></span><br><span class="line"><span class="comment">    * 字节根据平台的默认字符编码，这些</span></span><br><span class="line"><span class="comment">    * 字节的写入方式与 &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">    * #write（int）&#125; 方法。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> d 要打印的 &#123;<span class="doctag">@code</span> double&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> java.lang.Double#toString（double）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">double</span> d)</span> &#123;</span><br><span class="line">       write(String.valueOf(d));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *打印字符数组。 字符转换为字节</span></span><br><span class="line"><span class="comment">    * 根据给定给构造函数的字符编码，或</span></span><br><span class="line"><span class="comment">    * 平台的默认字符编码（如果未指定）。这些字节</span></span><br><span class="line"><span class="comment">    * 完全按照 &#123;<span class="doctag">@link</span> #write（int）&#125; 方法的方式编写。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> s 要打印的字符数组</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException 如果 &#123;<span class="doctag">@code</span> s&#125; 为 &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span> s[])</span> &#123;</span><br><span class="line">       write(s);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 打印字符串。 如果参数为 &#123;<span class="doctag">@code</span> null&#125;，则字符串</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> “null”&#125; 被打印出来。 否则，字符串的字符为</span></span><br><span class="line"><span class="comment">    * 根据给定的字符编码转换为字节</span></span><br><span class="line"><span class="comment">    * 构造函数，或平台的默认字符编码（如果为否）</span></span><br><span class="line"><span class="comment">    *指定。这些字节的写入方式与</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #write（int）&#125; 方法。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> s 要打印的 &#123;<span class="doctag">@code</span> String&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       write(String.valueOf(s));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *打印对象。 由 &#123;<span class="doctag">@link</span> 生成的字符串</span></span><br><span class="line"><span class="comment">    * java.lang.String#valueOf（Object）&#125; 方法转换为字节</span></span><br><span class="line"><span class="comment">    * 根据平台默认的字符编码，以及这些字节</span></span><br><span class="line"><span class="comment">    * 完全按照</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #write（int）&#125; 方法。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> obj 要打印的 &#123;<span class="doctag">@code</span> 对象&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> java.lang.Object#toString（）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">       write(String.valueOf(obj));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="五、方法的递归调用"><a href="#五、方法的递归调用" class="headerlink" title="五、方法的递归调用"></a>五、方法的递归调用</h2><h3 id="5-1、概念"><a href="#5-1、概念" class="headerlink" title="5.1、概念"></a>5.1、概念</h3><p>方法的递归调用是指在方法的执行过程中直接或间接地调用自己</p><p>。<br>递归是一种常用的编程技术，特别适用于解决可以被分解为相同问题的子问题的情况，例如树的遍历、阶乘计算、斐波那契数列等。</p><h3 id="5-2、在使用递归调用时，需要注意以下几点"><a href="#5-2、在使用递归调用时，需要注意以下几点" class="headerlink" title="5.2、在使用递归调用时，需要注意以下几点"></a>5.2、在使用递归调用时，需要注意以下几点</h3><p><strong>1、递归终止条件：</strong> 在递归方法中，必须包含递归终止条件，以避免无限递归调用，导致栈溢出。递归调用如果没有结束条件的话，会出现栈内存溢出错误： java.lang.StackOverflowError<br><strong>2、递归调用栈</strong>： 每次进行递归调用时，都会在调用栈上创建一个新的方法调用帧。因此，递归调用的层数不能太深，否则可能导致栈溢出错误。<br><strong>3、性能考虑：</strong> 递归调用可能会导致性能下降，因为每次递归调用都会涉及方法调用、栈帧的创建和销毁等操作。在某些情况下，使用迭代或其他方法可能更有效。<br><strong>4、空间复杂度：</strong> 递归调用的空间复杂度通常较高，因为需要在调用栈上保存每次方法调用的状态。在设计递归算法时，应该考虑到这一点。<br><strong>5、测试和调试：</strong> 递归调用的测试和调试可能比较困难，因为需要考虑递归的深度和复杂度。可以使用断点调试、打印调试信息等方法来帮助理解和调试递归算法。    </p><blockquote><p>在实际开发中，如果因为递归调用发生了栈内存溢出错误，该怎么办？<br>首先可以调整栈内存的大小。扩大栈内存。<br>如果扩大之后，运行一段时间还是出现了栈内存溢出错误。<br>可能是因为递归结束条件不对。需要进行代码的修改。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodRecursionTest01</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> jieCheng(n);</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">jieCheng</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n * jieCheng(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
          <category> Java Part_1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Switch语句</title>
      <link href="/2024/04/25/Switch%E8%AF%AD%E5%8F%A5/"/>
      <url>/2024/04/25/Switch%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="Switch-语句"><a href="#Switch-语句" class="headerlink" title="Switch 语句"></a>Switch 语句</h1><h2 id="一、case-语句可以合并"><a href="#一、case-语句可以合并" class="headerlink" title="一、case 语句可以合并"></a>一、case 语句可以合并</h2><p>case 后面只能是字面量值这样的值，不能使用变量。    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">month</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        String str;</span><br><span class="line">        <span class="keyword">switch</span>(month) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                str=<span class="string">&quot;春天&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span> : <span class="keyword">case</span> <span class="number">7</span>: <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                str=<span class="string">&quot;夏天&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>: <span class="keyword">case</span> <span class="number">10</span>: <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">                str=<span class="string">&quot;秋天&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">12</span>: <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                str=<span class="string">&quot;冬天&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: str=<span class="string">&quot;请输入正确月份&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、Java12-中-switch-的新特性"><a href="#二、Java12-中-switch-的新特性" class="headerlink" title="二、Java12 中 switch 的新特性"></a>二、Java12 中 switch 的新特性</h2><p>增强的 switch 语句是 Java 12 中引入的一项语言特性，它在 Java 14 中得到了进一步改进。这个特性的目的是提供更简洁、灵活和易读的 switch 语法。   </p><p>传统的 switch 语句在处理多个条件分支时可能存在一些问题，例如需要使用 break 语句显式地结束每个分支，容易出现忘记添加 break 而导致多个分支执行的情况。</p><p>增强的 switch 语句解决了这些问题，并引入了一些新的语法特性。     </p><p><strong>增强的 switch 语句的特点如下：</strong></p><ul><li>使用表达式作为分支条件：增强的 switch 语句允许在每个 case 分支中使用表达式，而不仅限于常量。这使得代码更加灵活，可以更方便地处理各种条件。</li><li>无需显式 break：在传统的 switch 语句中，每个 case 分支必须以 break 语句结束，否则会继续执行下一个分支。而增强的 switch 语句不需要显式地使用 break，每个分支会自动结束，不会继续执行下一个分支。</li><li>使用箭头(-&gt;)：在增强的 switch 语句中，分支的语法使用箭头(-&gt;)来连接分支的条件和执行语句，这使得代码更加简洁和易读。</li><li>引入 yield 关键字：在 Java 14 中，增强的 switch 语句引入了 yield 关键字，用于在分支中返回值。这使得 switch 语句可以像表达式一样返回值，增强了其功能性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnhancedSwitchExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dayType</span> <span class="operator">=</span> <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> -&gt; <span class="string">&quot;Weekday&quot;</span>; <span class="comment">// 使用表达式作为分支条件</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>, <span class="number">7</span> -&gt; <span class="string">&quot;Weekend&quot;</span>;</span><br><span class="line">            <span class="keyword">default</span> -&gt; &#123; <span class="comment">// default 分支</span></span><br><span class="line">                <span class="keyword">yield</span> <span class="string">&quot;Invalid day&quot;</span>; <span class="comment">// 使用 yield 返回值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;Day type: &quot;</span> + dayType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Switch01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>-&gt; System.out.println(<span class="string">&quot;switch&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span> -&gt; System.out.println(<span class="string">&quot;Change in&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span> -&gt; System.out.println(<span class="string">&quot;Java12&quot;</span>);</span><br><span class="line">            <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Switch02</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (expression)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> -&gt; System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">            <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Switch03</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (expression)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> -&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Wow!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
          <category> Java Part_1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量类型</title>
      <link href="/2024/04/23/%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/04/23/%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h1><h2 id="一、整型变量"><a href="#一、整型变量" class="headerlink" title="一、整型变量"></a>一、整型变量</h2><p>byte &lt; short &lt; int &lt; long &lt; float &lt; double</p><blockquote><p>在 Java 中任何一个整数型字面量都会被默认被当做 int 类型来处理。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 100 是 4 个字节，b 是八个字节。</span></span><br><span class="line">        <span class="comment">// 所以存在自动类型类型转换。</span></span><br><span class="line">        <span class="type">long</span> b=<span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 这个不存在类型转换。</span></span><br><span class="line">        <span class="type">long</span> c=<span class="number">100L</span>;</span><br><span class="line">        <span class="comment">// 这个会报错，原因是 = 右边先执行，这个整型字面量会以 int 类型处理，显然超过了 int 范围所以报错。其错误的原因在这。</span></span><br><span class="line">        <span class="type">long</span> e=<span class="number">2147483648</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1、自动类型转换"><a href="#1-1、自动类型转换" class="headerlink" title="1.1、自动类型转换"></a>1.1、自动类型转换</h3><p>可以理解为从小容量到大容量。程序员不需要明确地指定转换操作，而是由编程语言的规则自动执行。</p><h3 id="1-2、-强制类型转换"><a href="#1-2、-强制类型转换" class="headerlink" title="1.2、 强制类型转换"></a>1.2、 强制类型转换</h3><p>大容量转换为小容量，可能会有精度损失。Java 编程语言不会自动转换，由程序员自己强制转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 经典的例子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> k=<span class="number">128</span>;</span><br><span class="line">        <span class="type">byte</span> e=(<span class="type">byte</span>)k; <span class="comment">//-128</span></span><br><span class="line">        <span class="type">int</span> m=<span class="number">129</span>;</span><br><span class="line">        <span class="type">byte</span> n=(<span class="type">byte</span>)m; -<span class="number">127</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>注意：<ul><li>当一个整数型字面量没有超过对应变量类型范围时，可以直接赋值给对应变量类型的变量。</li><li>byte 和 short 混合运算的时候，先各自转换为 int 再做运算。(byte+byte–&gt;int、 byte+short–&gt;int、 short+short–&gt;int)</li><li>当一个整数型字面量没有超过对应变量类型范围时，可以直接赋值给对应变量类型的变量。</li><li>注意强转时前后都要加（），因为优先级不同。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span> b=<span class="number">1</span>;</span><br><span class="line">        <span class="type">byte</span> a=<span class="number">127</span>;</span><br><span class="line">        <span class="comment">// 按道理这个由 int 转换为 byte 没有强转的话因该报错。</span></span><br><span class="line">        <span class="comment">// 其实这是 Java 语言开发者给程序员的优化措施。</span></span><br><span class="line">        <span class="comment">// 规则：当一个整数型字面量没有超过对应变量类型范围时，可以直接赋值给对应变量类型的变量。</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">short</span> m=<span class="number">10</span>;</span><br><span class="line">        <span class="type">byte</span> n=<span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 编译器报错，最后结果是 int 类型，不能用 short 变量接收。（注意和字面量的区别）</span></span><br><span class="line">        <span class="type">short</span> result=m+n;</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span> c=<span class="number">10</span>/<span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 10/3 都是字面量，所以会在编译器就计算出来。即在源码 ByteTest.java 中是 byte c=10/3,但是在编译后 ByteTest.class 中 byte c=3;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span> x=<span class="number">10</span>;</span><br><span class="line">        <span class="type">byte</span> y=<span class="number">3</span>;</span><br><span class="line">        <span class="type">byte</span> d=x/y;</span><br><span class="line">        <span class="comment">// 编译器报错,在编译阶段只能知道 x/y 结果为 int，只有在正式运行才知道 x,y 里面存的是什么。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、浮点型变量"><a href="#二、浮点型变量" class="headerlink" title="二、浮点型变量"></a>二、浮点型变量</h2><ul><li>float：单精度，可以精确到 7 位小数。    </li><li>double：双精度，可以精确到 15 位小数。   </li><li>浮点型的字面量默认当做 double 类型处理，要用 float 类型处理需要在字面量后面加 F&#x2F;f。</li><li>浮点型数据有两种表示形式：十进制、科学计数法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不存在类型转换</span></span><br><span class="line"><span class="type">float</span> f=<span class="number">3.14F</span>;</span><br><span class="line"><span class="comment">// 借助强制类型转换</span></span><br><span class="line"><span class="type">float</span> f=(<span class="type">float</span>)<span class="number">3.14</span>;</span><br></pre></td></tr></table></figure><h3 id="2-1、浮点型数据存储原理"><a href="#2-1、浮点型数据存储原理" class="headerlink" title="2.1、浮点型数据存储原理"></a>2.1、浮点型数据存储原理</h3><p>浮点型数据存储原理涉及到计算机中的浮点数表示方法。通常情况下，浮点数由两部分组成：尾数（mantissa）和指数（exponent），以及一个符号位（sign bit），用来表示正负。</p><p>常见的浮点数表示方法是 IEEE 754 标准，它定义了单精度浮点数（32 位）和双精度浮点数（64 位）的存储格式。<br>在 IEEE 754 标准中，单精度浮点数的存储结构如下：</p><ul><li>符号位：1 位</li><li>指数位：8 位</li><li>尾数位：23 位</li></ul><p>双精度浮点数的存储结构如下：</p><ul><li>符号位：1 位</li><li>指数位：11 位</li><li>尾数位：52 位</li></ul><p>浮点数的实际值通过指数和尾数来表示。指数用来表示浮点数的数量级，尾数用来表示浮点数的精度。符号位用来表示浮点数的正负。</p><p>浮点数的存储原理基于科学计数法，即一个数可以表示为尾数乘以基数的指数次方。例如，对于单精度浮点数，可以表示为：<br>$$<br>(-1)^{\text{sign}} \times (1 + \text{mantissa}) \times 2^{\text{exponent} - \text{bias}}<br>$$</p><p>其中，sign 是符号位，mantissa 是尾数，exponent 是指数，bias 是偏置值（用于使指数可以表示负数）。这个公式基本上适用于双精度浮点数，只是指数偏置和尾数位数不同。</p><h2 id="三、字符型"><a href="#三、字符型" class="headerlink" title="三、字符型"></a>三、字符型</h2><h3 id="3-1、char"><a href="#3-1、char" class="headerlink" title="3.1、char"></a>3.1、char</h3><p>Java 中的 char 类型使用 Unicode 编码来表示字符。每个字符对应一个</p><p>唯一的 Unicode 码点，可以通过 \u 后跟 4 位十六进制数来表示。</p><h3 id="3-2、转义字符"><a href="#3-2、转义字符" class="headerlink" title="3.2、转义字符"></a>3.2、转义字符</h3><ul><li>\n： 换行符（newline），在输出时表示换行。    </li><li>\t： 制表符（tab），在输出时表示水平制表。    </li><li>\r： 回车符（carriage return），在输出时表示回车。    </li><li>‘： 单引号（single quote），用于表示单引号字符。    </li><li>“： 双引号（double quote），用于表示双引号字符。    </li><li>\： 反斜杠（backslash），用于表示反斜杠字符本身。</li></ul><h3 id="3-3、乱码"><a href="#3-3、乱码" class="headerlink" title="3.3、乱码"></a>3.3、乱码</h3><p>乱码通常是由于文本数据的编码方式与解码方式不匹配或者编码过程中出现了错误所致。<br>所以一定要保持编码与解码一致。</p><h3 id="3-4、char-参与运算"><a href="#3-4、char-参与运算" class="headerlink" title="3.4、char 参与运算"></a>3.4、char 参与运算</h3><p>byte、short、char 混合运算的时候，先各自转换为 int 再做运算。<br>多种数据类型混合运算的时候放，先各自转换为最大的再做运算。   </p><h2 id="四、boolean-类型"><a href="#四、boolean-类型" class="headerlink" title="四、boolean 类型"></a>四、boolean 类型</h2><p>在 Java 中，boolean 的值只有 true、false。（与 C、C++ 有所不同）</p><p><strong>总结：基本数据类型转换规则</strong>   </p><blockquote><p>1、八种基本数据类型除了 boolean 类型之外，都可以互相转换。<br>2、小容量可以自动转换为大容量，容量排序为：byte &lt; short,char &lt; int &lt; long &lt; float &lt; double<br>3、大容量不能自动转换为小容量，必须添加强制类型转换符，才能编译通过，但是运行时可能损失精度。<br>4、当整数型字面量没有超过 byte、short、char 的范围时，可以将其赋值给 byte、short、char 类型的变量。<br>5、byte、short、char 混合运算时，各自先转换为 int 再做运算。<br>6、多种数据类型混合运算的时候放，先各自转换为最大的再做运算。    </p></blockquote><p><strong>注意：</strong></p><blockquote><p>1、long e&#x3D;2147483648; 这个属于一个经典面试题，其错误的原因是 &#x3D; 右边先执行，这个整型字面量会以 int 类型处理，显然超过了 int 范围所以报错。<br>2、理解 byte a&#x3D;10&#x2F;3; 不报错，但是 byte b&#x3D;10; byte c&#x3D;3; a&#x3D;b&#x2F;3; 报错。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
          <category> Java Part_1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java SE基础知识</title>
      <link href="/2024/04/20/Java-SE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/04/20/Java-SE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-SE-基础知识"><a href="#Java-SE-基础知识" class="headerlink" title="Java SE 基础知识"></a>Java SE 基础知识</h1><h2 id="一、Java虚拟机（JVM）"><a href="#一、Java虚拟机（JVM）" class="headerlink" title="一、Java虚拟机（JVM）"></a>一、Java虚拟机（JVM）</h2><p><img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/asserts_JavaSE/202405011249837.png"></p><h2 id="二、Java的加载与执行原理"><a href="#二、Java的加载与执行原理" class="headerlink" title="二、Java的加载与执行原理"></a>二、Java的加载与执行原理</h2><p><img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/asserts_JavaSE/202405011250158.PNG"></p><h2 id="三、JDK、JRE、JVM分别是什么？他们的关系是什么？"><a href="#三、JDK、JRE、JVM分别是什么？他们的关系是什么？" class="headerlink" title="三、JDK、JRE、JVM分别是什么？他们的关系是什么？"></a>三、JDK、JRE、JVM分别是什么？他们的关系是什么？</h2><ol><li><p><strong>JDK（Java Development Kit）：</strong><br>JDK 是 Java 开发工具包，它是 Java 开发者用来开发 Java 应用程序的核心组件。JDK 包括了 Java 编译器（javac）、Java 运行时环境（JRE）、Java 文档生成器（Javadoc）以及其他一些开发工具和库。简而言之，JDK 提供了开发 Java 应用程序所需的所有工具和资源。</p></li><li><p><strong>JRE（Java Runtime Environment）：</strong><br>JRE 是 Java 运行时环境，它是在运行 Java 应用程序时所必需的环境。JRE 包含了 Java 虚拟机（JVM）以及 Java 核心类库和支持文件。当用户想要运行一个已编译的 Java 应用程序时，他们需要安装 JRE。JRE 提供了 Java 应用程序的运行环境，但不包含开发工具。</p></li><li><p><strong>JVM（Java Virtual Machine）：</strong><br>JVM 是 Java 虚拟机，它是 Java 程序的运行环境。JVM 负责在实际的硬件平台上执行 Java 字节码（即编译后的 Java 代码）。JVM 负责加载字节码、解释执行或即时编译字节码为本地机器代码，并管理内存、执行垃圾回收等任务。JVM 的存在使得 Java 能够实现“一次编写，到处运行”的特性。</p><img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/asserts_JavaSE/202405011250370.png"  height="300" width="300"></li></ol><h2 id="四、class和public-class的区别"><a href="#四、class和public-class的区别" class="headerlink" title="四、class和public class的区别"></a>四、class和public class的区别</h2><ol><li>一个 Java 源文件可以定义多个 class。</li><li>编译之后，一个 class 就会对应生成一个 class 字节码文件。</li><li>如果一个类是 public，类名必须要和源文件名保持一致。</li><li>public 类可以没有，如果有的话也只能有一个。</li><li>每个类中都可以编写入口 main 方法。在实际开发中，入口一般只有一个。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;X执行了，这个 Java 源文件名为 X.java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、Java标识符命名规范"><a href="#五、Java标识符命名规范" class="headerlink" title="五、Java标识符命名规范"></a>五、Java标识符命名规范</h2><p>遵循驼峰式命名方法。   </p><ul><li><strong>类名、接口名：</strong> 首字母大写吗，后面每个单词首字母大写。 <code>StudentService</code>    </li><li><strong>变量名、方法名：</strong> 首字母小写，后面每个单词首字母大写。 <code>productPrice</code>    </li><li><strong>常量名：</strong> 全部大写，每个单词之间采用”_”分隔。 <code>LOGIN_SUCCESS</code>    </li><li><strong>包名：</strong> 全部小写。 <code>com.camellia.javase.extends</code></li></ul><h2 id="六、Java中的加号运算符"><a href="#六、Java中的加号运算符" class="headerlink" title="六、Java中的加号运算符"></a>六、Java中的加号运算符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlusTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> b=<span class="number">20</span>;</span><br><span class="line">        String str=<span class="string">&quot;10&quot;</span>;</span><br><span class="line">        <span class="comment">// 字符串拼接</span></span><br><span class="line">        System.out.println(str + b); <span class="comment">// 1020;</span></span><br><span class="line">        </span><br><span class="line">        str=<span class="string">&quot;30&quot;</span>;</span><br><span class="line">        <span class="comment">// 当一个表达式中出现多个+，若没有（），遵循从左到右。</span></span><br><span class="line">        System.out.println(a + b + str); <span class="comment">// 3030;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加了（）优先级比较高。</span></span><br><span class="line">        System.out.println(a+(b+str)); <span class="comment">// 102030</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、变量的分类"><a href="#七、变量的分类" class="headerlink" title="七、变量的分类"></a>七、变量的分类</h2><ul><li><p><strong>局部变量（Local Variables）：</strong><br>在方法、代码块或构造方法中声明的变量称为局部变量。局部变量只在其声明的范围内可见，超出该范围就无法访问。局部变量的生命周期仅在其声明的代码块、方法或构造方法执行期间。当代码块或方法执行完毕时，局部变量将被销毁。    </p></li><li><p><strong>成员变量（Instance Variables）：</strong><br>在类中声明的变量，但在方法之外，类的任何地方都可以访问，称为成员变量或实例变量。每个对象都有一份成员变量的副本，它们属于对象的状态。成员变量的生命周期与对象的生命周期相同。它们随着对象的创建而创建，随着对象的销毁而销毁。    </p></li><li><p><strong>静态变量（Static Variables）：</strong><br>使用 static 关键字声明的成员变量称为静态变量。静态变量属于类而不是对象，在类加载时初始化，并且所有对象共享同一份静态变量。静态变量的生命周期与类的生命周期相同。它们在类加载时初始化，随着类的卸载而销毁。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 变量可以根据定义/声明的位置来进行分类，可以分为两大类：</span></span><br><span class="line"><span class="comment">        1、局部变量</span></span><br><span class="line"><span class="comment">        2、成员变量</span></span><br><span class="line"><span class="comment">          - 静态变量</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> - 实例变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VarClassify</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 凡是在方法体中定义的变量，一定是局部变量。</span></span><br><span class="line">        <span class="comment">// 局部变量只在当前方法体中有效。</span></span><br><span class="line">        <span class="type">int</span> a=<span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在类中定义的变量叫做成员变量。</span></span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="type">int</span> b=<span class="number">200</span>;</span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> c=<span class="number">300</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><blockquote><p>Java 是一种混合型语言，既有编译阶段也有解释阶段。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
          <category> Java Part_1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
