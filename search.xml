<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Method（方法）</title>
      <link href="/2024/05/04/Method%EF%BC%88%E6%96%B9%E6%B3%95%EF%BC%89/"/>
      <url>/2024/05/04/Method%EF%BC%88%E6%96%B9%E6%B3%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Method-方法"><a href="#Method-方法" class="headerlink" title="Method (方法)"></a>Method (方法)</h1><h2 id="一、静态方法什么时候需要用类名调用？"><a href="#一、静态方法什么时候需要用类名调用？" class="headerlink" title="一、静态方法什么时候需要用类名调用？"></a>一、静态方法什么时候需要用类名调用？</h2><p>调用者和被调用者在同一个类中时，可以省略。    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用方法是，类名. 什么情况下可以省略。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//调用method1</span></span><br><span class="line">        method1();</span><br><span class="line">        MethodTest01.method1();</span><br><span class="line">        <span class="comment">//调用method2</span></span><br><span class="line">        <span class="comment">/*method2(); 编译器报错*/</span></span><br><span class="line">        MethodTest.method2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;mothod1执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">MethodTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method2执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、方法语法的小细节"><a href="#二、方法语法的小细节" class="headerlink" title="二、方法语法的小细节"></a>二、方法语法的小细节</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest05</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缺少返回语句</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">99</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//虽然这里有返回语句，但是有几率不执行if语句。所以编译器不通过。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、方法执行的内存图"><a href="#三、方法执行的内存图" class="headerlink" title="三、方法执行的内存图"></a>三、方法执行的内存图</h2><blockquote><p><strong>概念：</strong> Java 的元空间（Metaspace）是 Java 虚拟机（JVM）用来存储类元数据的内存区域。在传统的 Java 虚拟机实现中，类元数据通常存储在永久代（Permanent Generation）中。但是，从 JDK 8 开始，永久代被移除，取而代之的是元空间。 </p><p><strong>元空间与永久代相比有几个显著的不同点：</strong></p><ul><li>内存位置： 元空间不是在 Java 虚拟机的堆内存中，而是位于本地内存中。这使得元空间的大小不受堆内存的限制，可以动态地根据应用程序的需要调整大小。</li><li>自动调整大小： 元空间的大小可以根据应用程序的需要动态调整，因此不容易出现类加载溢出的情况。在使用元空间时，不需要手动设置元空间的大小，JVM 会根据应用程序的需求自动调整。</li><li>内存回收： 元空间的内存是由 JVM 进行管理的，不需要像永久代一样手动进行垃圾回收。当类加载器不再需要某些类的元数据时，JVM 会自动进行回收，而不会出现永久代中的内存泄漏问题。</li><li>垃圾收集器： 元空间的垃圾收集与堆内存的垃圾收集不同，通常不会触发 Full GC。类加载器卸载类时，相关的元数据会被及时回收，不会等待垃圾收集器的触发。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.方法如果只定义，不调用是不会分配内存空间。（从Java8开始，方法的字节码指令存储在元空间metaspace当中。元空间使用的是本地内存。）</span></span><br><span class="line"><span class="comment">2.方法调用的瞬间，会在JVM的栈内存当中分配活动场所，此时发生压栈动作。</span></span><br><span class="line"><span class="comment">3.方法一旦结束，给该方法分配的内存空间就会释放。此时发生弹栈动作。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest02</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main begin&quot;</span>);</span><br><span class="line">        m1();</span><br><span class="line">        System.out.println(<span class="string">&quot;main over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1 begin&quot;</span>);</span><br><span class="line">        m2();</span><br><span class="line">        System.out.println(<span class="string">&quot;m1 over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m2 begin&quot;</span>);</span><br><span class="line">        m3();</span><br><span class="line">        System.out.println(<span class="string">&quot;m2 over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m3 begin&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;m3 over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/asserts_JavaSE/202405011253474.png"></p><h2 id="四、方法重载"><a href="#四、方法重载" class="headerlink" title="四、方法重载"></a>四、方法重载</h2><h3 id="4-1、在-Java-中，方法重载需要满足以下条件："><a href="#4-1、在-Java-中，方法重载需要满足以下条件：" class="headerlink" title="4.1、在 Java 中，方法重载需要满足以下条件："></a>4.1、在 Java 中，方法重载需要满足以下条件：</h3><ol><li><strong>方法名称相同：</strong> 重载方法的名称必须相同。</li><li><strong>参数列表不同：</strong> 重载方法的参数列表必须不同，可以通过参数的数量、类型或者顺序来区分不同的重载方法。</li><li><strong>返回类型可以不同：</strong> 重载方法的返回类型可以相同也可以不同。但是，仅仅通过返回类型的不同是无法实现方法重载的，因为 Java 中不允许仅通过返回类型的不同来区分不同的方法。</li><li><strong>访问修饰符、方法体、抛出的异常可以相同也可以不同：</strong> 重载方法的访问修饰符、方法体、以及方法中可能抛出的异常可以相同也可以不同。</li><li><strong>方法重载与参数的名称无关：</strong> 方法重载与参数的名称无关，只与参数列表的类型、数量和顺序有关。</li></ol><h3 id="4-2、方法重载示例代码"><a href="#4-2、方法重载示例代码" class="headerlink" title="4.2、方法重载示例代码"></a>4.2、方法重载示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法重载是编译阶段的机制还是运行阶段的机制？</span></span><br><span class="line"><span class="comment">方法重载机制是编译阶段的机制。</span></span><br><span class="line"><span class="comment">在编译阶段已经完成了方法的绑定。</span></span><br><span class="line"><span class="comment">在编译阶段已经确定了要调用哪个方法了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">什么情况下我们考虑使用方法重载呢？</span></span><br><span class="line"><span class="comment">在以后的开发中，在一个类中，如果两个方法的功能相似，建议将方法名定义为同一个名字。</span></span><br><span class="line"><span class="comment">此时就使用了方法重载机制。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodOverloadTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        m1();</span><br><span class="line">        m1</span><br><span class="line"></span><br><span class="line">(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        m2(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        m2(<span class="number">10L</span>, <span class="number">20L</span>);</span><br><span class="line"></span><br><span class="line">        m3(<span class="string">&quot;x&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        m3(<span class="number">10</span>, <span class="string">&quot;x&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 形参的个数不同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1(String s)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 形参类型不同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m2(int a, int b)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m2(long a, long b)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 形参顺序不同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">(String s, <span class="type">int</span> a)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m3(String s, int a)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">(<span class="type">int</span> a, String s)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m3(int a, String s)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下这两个方法没有构成方法重载，属于方法重复定义了。语法错误，编译器报错。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public static void doSome(int a, int b)&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">public static void doSome(int x, int y)&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3、println方法重载源码-部分"><a href="#4-3、println方法重载源码-部分" class="headerlink" title="4.3、println方法重载源码(部分)"></a>4.3、println方法重载源码(部分)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Methods that do not terminate lines */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 打印布尔值。 &#123;<span class="doctag">@link</span> 生成的字符串</span></span><br><span class="line"><span class="comment">    * java.lang.String#valueOf（boolean）&#125; 被转换为字节</span></span><br><span class="line"><span class="comment">    * 根据平台默认的字符编码，以及这些字节</span></span><br><span class="line"><span class="comment">    * 完全按照</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #write（int）&#125; 方法。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> b 要打印的 &#123;<span class="doctag">@code</span> 布尔值&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">       write(String.valueOf(b));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 打印字符。 该字符将转换为一个或多个字节</span></span><br><span class="line"><span class="comment">    * 根据给定给构造函数的字符编码，或</span></span><br><span class="line"><span class="comment">    * 平台的默认字符编码（如果未指定）。这些字节</span></span><br><span class="line"><span class="comment">    * 完全按照 &#123;<span class="doctag">@link</span> #write（int）&#125; 方法的方式编写。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> c 要打印的 &#123;<span class="doctag">@code</span> 字符&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">       write(String.valueOf(c));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 打印整数。 &#123;<span class="doctag">@link</span> 生成的字符串</span></span><br><span class="line"><span class="comment">    * java.lang.String#valueOf（int）&#125; 被转换为字节</span></span><br><span class="line"><span class="comment">    * 根据平台默认的字符编码，以及这些字节</span></span><br><span class="line"><span class="comment">    * 完全按照</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #write（int）&#125; 方法。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> i 要打印的 &#123;<span class="doctag">@code</span> int&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> java.lang.Integer#toString（int）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">       write(String.valueOf(i));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 打印长整数。 &#123;<span class="doctag">@link</span> 生成的字符串</span></span><br><span class="line"><span class="comment">    * java.lang.String#valueOf（long）&#125; 被翻译成字节</span></span><br><span class="line"><span class="comment">    * 根据平台默认的字符编码，以及这些字节</span></span><br><span class="line"><span class="comment">    * 完全按照</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #write（int）&#125; 方法。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> l 要打印的 &#123;<span class="doctag">@code</span> long&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> java.lang.Long#toString（long）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">long</span> l)</span> &#123;</span><br><span class="line">       write(String.valueOf(l));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 打印浮点数。 &#123;<span class="doctag">@link</span> 生成的字符串</span></span><br><span class="line"><span class="comment">    * java.lang.String#valueOf（float）&#125; 被转换为字节</span></span><br><span class="line"><span class="comment">    * 根据平台默认的字符编码，以及这些字节</span></span><br><span class="line"><span class="comment">    * 完全按照</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #write（int）&#125; 方法。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> f 要打印的 &#123;<span class="doctag">@code</span> float&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> java.lang.Float#toString（float）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">float</span> f)</span> &#123;</span><br><span class="line">       write(String.valueOf(f));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 打印双精度浮点数。 生成的字符串</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> java.lang.String#valueOf（double）&#125; 被翻译成</span></span><br><span class="line"><span class="comment">    * 字节根据平台的默认字符编码，这些</span></span><br><span class="line"><span class="comment">    * 字节的写入方式与 &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">    * #write（int）&#125; 方法。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> d 要打印的 &#123;<span class="doctag">@code</span> double&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> java.lang.Double#toString（double）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">double</span> d)</span> &#123;</span><br><span class="line">       write(String.valueOf(d));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *打印字符数组。 字符转换为字节</span></span><br><span class="line"><span class="comment">    * 根据给定给构造函数的字符编码，或</span></span><br><span class="line"><span class="comment">    * 平台的默认字符编码（如果未指定）。这些字节</span></span><br><span class="line"><span class="comment">    * 完全按照 &#123;<span class="doctag">@link</span> #write（int）&#125; 方法的方式编写。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> s 要打印的字符数组</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException 如果 &#123;<span class="doctag">@code</span> s&#125; 为 &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span> s[])</span> &#123;</span><br><span class="line">       write(s);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 打印字符串。 如果参数为 &#123;<span class="doctag">@code</span> null&#125;，则字符串</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> “null”&#125; 被打印出来。 否则，字符串的字符为</span></span><br><span class="line"><span class="comment">    * 根据给定的字符编码转换为字节</span></span><br><span class="line"><span class="comment">    * 构造函数，或平台的默认字符编码（如果为否）</span></span><br><span class="line"><span class="comment">    *指定。这些字节的写入方式与</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #write（int）&#125; 方法。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> s 要打印的 &#123;<span class="doctag">@code</span> String&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       write(String.valueOf(s));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *打印对象。 由 &#123;<span class="doctag">@link</span> 生成的字符串</span></span><br><span class="line"><span class="comment">    * java.lang.String#valueOf（Object）&#125; 方法转换为字节</span></span><br><span class="line"><span class="comment">    * 根据平台默认的字符编码，以及这些字节</span></span><br><span class="line"><span class="comment">    * 完全按照</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #write（int）&#125; 方法。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> obj 要打印的 &#123;<span class="doctag">@code</span> 对象&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> java.lang.Object#toString（）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">       write(String.valueOf(obj));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="五、方法的递归调用"><a href="#五、方法的递归调用" class="headerlink" title="五、方法的递归调用"></a>五、方法的递归调用</h2><h3 id="5-1、概念"><a href="#5-1、概念" class="headerlink" title="5.1、概念"></a>5.1、概念</h3><p>方法的递归调用是指在方法的执行过程中直接或间接地调用自己</p><p>。<br>递归是一种常用的编程技术，特别适用于解决可以被分解为相同问题的子问题的情况，例如树的遍历、阶乘计算、斐波那契数列等。</p><h3 id="5-2、在使用递归调用时，需要注意以下几点"><a href="#5-2、在使用递归调用时，需要注意以下几点" class="headerlink" title="5.2、在使用递归调用时，需要注意以下几点"></a>5.2、在使用递归调用时，需要注意以下几点</h3><p><strong>1、递归终止条件：</strong> 在递归方法中，必须包含递归终止条件，以避免无限递归调用，导致栈溢出。递归调用如果没有结束条件的话，会出现栈内存溢出错误： java.lang.StackOverflowError<br><strong>2、递归调用栈</strong>： 每次进行递归调用时，都会在调用栈上创建一个新的方法调用帧。因此，递归调用的层数不能太深，否则可能导致栈溢出错误。<br><strong>3、性能考虑：</strong> 递归调用可能会导致性能下降，因为每次递归调用都会涉及方法调用、栈帧的创建和销毁等操作。在某些情况下，使用迭代或其他方法可能更有效。<br><strong>4、空间复杂度：</strong> 递归调用的空间复杂度通常较高，因为需要在调用栈上保存每次方法调用的状态。在设计递归算法时，应该考虑到这一点。<br><strong>5、测试和调试：</strong> 递归调用的测试和调试可能比较困难，因为需要考虑递归的深度和复杂度。可以使用断点调试、打印调试信息等方法来帮助理解和调试递归算法。    </p><blockquote><p>在实际开发中，如果因为递归调用发生了栈内存溢出错误，该怎么办？<br>首先可以调整栈内存的大小。扩大栈内存。<br>如果扩大之后，运行一段时间还是出现了栈内存溢出错误。<br>可能是因为递归结束条件不对。需要进行代码的修改。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodRecursionTest01</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> jieCheng(n);</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">jieCheng</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n * jieCheng(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
          <category> Java Part_1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Switch语句</title>
      <link href="/2024/05/04/Switch%E8%AF%AD%E5%8F%A5/"/>
      <url>/2024/05/04/Switch%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="Switch-语句"><a href="#Switch-语句" class="headerlink" title="Switch 语句"></a>Switch 语句</h1><h2 id="一、case-语句可以合并"><a href="#一、case-语句可以合并" class="headerlink" title="一、case 语句可以合并"></a>一、case 语句可以合并</h2><p>case 后面只能是字面量值这样的值，不能使用变量。    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">month</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        String str;</span><br><span class="line">        <span class="keyword">switch</span>(month) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                str=<span class="string">&quot;春天&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span> : <span class="keyword">case</span> <span class="number">7</span>: <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                str=<span class="string">&quot;夏天&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>: <span class="keyword">case</span> <span class="number">10</span>: <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">                str=<span class="string">&quot;秋天&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">12</span>: <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                str=<span class="string">&quot;冬天&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: str=<span class="string">&quot;请输入正确月份&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、Java12-中-switch-的新特性"><a href="#二、Java12-中-switch-的新特性" class="headerlink" title="二、Java12 中 switch 的新特性"></a>二、Java12 中 switch 的新特性</h2><p>增强的 switch 语句是 Java 12 中引入的一项语言特性，它在 Java 14 中得到了进一步改进。这个特性的目的是提供更简洁、灵活和易读的 switch 语法。   </p><p>传统的 switch 语句在处理多个条件分支时可能存在一些问题，例如需要使用 break 语句显式地结束每个分支，容易出现忘记添加 break 而导致多个分支执行的情况。</p><p>增强的 switch 语句解决了这些问题，并引入了一些新的语法特性。     </p><p><strong>增强的 switch 语句的特点如下：</strong></p><ul><li>使用表达式作为分支条件：增强的 switch 语句允许在每个 case 分支中使用表达式，而不仅限于常量。这使得代码更加灵活，可以更方便地处理各种条件。</li><li>无需显式 break：在传统的 switch 语句中，每个 case 分支必须以 break 语句结束，否则会继续执行下一个分支。而增强的 switch 语句不需要显式地使用 break，每个分支会自动结束，不会继续执行下一个分支。</li><li>使用箭头(-&gt;)：在增强的 switch 语句中，分支的语法使用箭头(-&gt;)来连接分支的条件和执行语句，这使得代码更加简洁和易读。</li><li>引入 yield 关键字：在 Java 14 中，增强的 switch 语句引入了 yield 关键字，用于在分支中返回值。这使得 switch 语句可以像表达式一样返回值，增强了其功能性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnhancedSwitchExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dayType</span> <span class="operator">=</span> <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> -&gt; <span class="string">&quot;Weekday&quot;</span>; <span class="comment">// 使用表达式作为分支条件</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>, <span class="number">7</span> -&gt; <span class="string">&quot;Weekend&quot;</span>;</span><br><span class="line">            <span class="keyword">default</span> -&gt; &#123; <span class="comment">// default 分支</span></span><br><span class="line">                <span class="keyword">yield</span> <span class="string">&quot;Invalid day&quot;</span>; <span class="comment">// 使用 yield 返回值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;Day type: &quot;</span> + dayType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Switch01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>-&gt; System.out.println(<span class="string">&quot;switch&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span> -&gt; System.out.println(<span class="string">&quot;Change in&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span> -&gt; System.out.println(<span class="string">&quot;Java12&quot;</span>);</span><br><span class="line">            <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Switch02</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (expression)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> -&gt; System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">            <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Switch03</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (expression)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> -&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Wow!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
          <category> Java Part_1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量类型</title>
      <link href="/2024/05/04/%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/05/04/%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h1><h2 id="一、整型变量"><a href="#一、整型变量" class="headerlink" title="一、整型变量"></a>一、整型变量</h2><p>byte &lt; short &lt; int &lt; long &lt; float &lt; double</p><blockquote><p>在 Java 中任何一个整数型字面量都会被默认被当做 int 类型来处理。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 100 是 4 个字节，b 是八个字节。</span></span><br><span class="line">        <span class="comment">// 所以存在自动类型类型转换。</span></span><br><span class="line">        <span class="type">long</span> b=<span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 这个不存在类型转换。</span></span><br><span class="line">        <span class="type">long</span> c=<span class="number">100L</span>;</span><br><span class="line">        <span class="comment">// 这个会报错，原因是 = 右边先执行，这个整型字面量会以 int 类型处理，显然超过了 int 范围所以报错。其错误的原因在这。</span></span><br><span class="line">        <span class="type">long</span> e=<span class="number">2147483648</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1、自动类型转换"><a href="#1-1、自动类型转换" class="headerlink" title="1.1、自动类型转换"></a>1.1、自动类型转换</h3><p>可以理解为从小容量到大容量。程序员不需要明确地指定转换操作，而是由编程语言的规则自动执行。</p><h3 id="1-2、-强制类型转换"><a href="#1-2、-强制类型转换" class="headerlink" title="1.2、 强制类型转换"></a>1.2、 强制类型转换</h3><p>大容量转换为小容量，可能会有精度损失。Java 编程语言不会自动转换，由程序员自己强制转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 经典的例子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> k=<span class="number">128</span>;</span><br><span class="line">        <span class="type">byte</span> e=(<span class="type">byte</span>)k; <span class="comment">//-128</span></span><br><span class="line">        <span class="type">int</span> m=<span class="number">129</span>;</span><br><span class="line">        <span class="type">byte</span> n=(<span class="type">byte</span>)m; -<span class="number">127</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>注意：<ul><li>当一个整数型字面量没有超过对应变量类型范围时，可以直接赋值给对应变量类型的变量。</li><li>byte 和 short 混合运算的时候，先各自转换为 int 再做运算。(byte+byte–&gt;int、 byte+short–&gt;int、 short+short–&gt;int)</li><li>当一个整数型字面量没有超过对应变量类型范围时，可以直接赋值给对应变量类型的变量。</li><li>注意强转时前后都要加（），因为优先级不同。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span> b=<span class="number">1</span>;</span><br><span class="line">        <span class="type">byte</span> a=<span class="number">127</span>;</span><br><span class="line">        <span class="comment">// 按道理这个由 int 转换为 byte 没有强转的话因该报错。</span></span><br><span class="line">        <span class="comment">// 其实这是 Java 语言开发者给程序员的优化措施。</span></span><br><span class="line">        <span class="comment">// 规则：当一个整数型字面量没有超过对应变量类型范围时，可以直接赋值给对应变量类型的变量。</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">short</span> m=<span class="number">10</span>;</span><br><span class="line">        <span class="type">byte</span> n=<span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 编译器报错，最后结果是 int 类型，不能用 short 变量接收。（注意和字面量的区别）</span></span><br><span class="line">        <span class="type">short</span> result=m+n;</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span> c=<span class="number">10</span>/<span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 10/3 都是字面量，所以会在编译器就计算出来。即在源码 ByteTest.java 中是 byte c=10/3,但是在编译后 ByteTest.class 中 byte c=3;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span> x=<span class="number">10</span>;</span><br><span class="line">        <span class="type">byte</span> y=<span class="number">3</span>;</span><br><span class="line">        <span class="type">byte</span> d=x/y;</span><br><span class="line">        <span class="comment">// 编译器报错,在编译阶段只能知道 x/y 结果为 int，只有在正式运行才知道 x,y 里面存的是什么。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、浮点型变量"><a href="#二、浮点型变量" class="headerlink" title="二、浮点型变量"></a>二、浮点型变量</h2><ul><li>float：单精度，可以精确到 7 位小数。    </li><li>double：双精度，可以精确到 15 位小数。   </li><li>浮点型的字面量默认当做 double 类型处理，要用 float 类型处理需要在字面量后面加 F&#x2F;f。</li><li>浮点型数据有两种表示形式：十进制、科学计数法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不存在类型转换</span></span><br><span class="line"><span class="type">float</span> f=<span class="number">3.14F</span>;</span><br><span class="line"><span class="comment">// 借助强制类型转换</span></span><br><span class="line"><span class="type">float</span> f=(<span class="type">float</span>)<span class="number">3.14</span>;</span><br></pre></td></tr></table></figure><h3 id="2-1、浮点型数据存储原理"><a href="#2-1、浮点型数据存储原理" class="headerlink" title="2.1、浮点型数据存储原理"></a>2.1、浮点型数据存储原理</h3><p>浮点型数据存储原理涉及到计算机中的浮点数表示方法。通常情况下，浮点数由两部分组成：尾数（mantissa）和指数（exponent），以及一个符号位（sign bit），用来表示正负。</p><p>常见的浮点数表示方法是 IEEE 754 标准，它定义了单精度浮点数（32 位）和双精度浮点数（64 位）的存储格式。<br>在 IEEE 754 标准中，单精度浮点数的存储结构如下：</p><ul><li>符号位：1 位</li><li>指数位：8 位</li><li>尾数位：23 位</li></ul><p>双精度浮点数的存储结构如下：</p><ul><li>符号位：1 位</li><li>指数位：11 位</li><li>尾数位：52 位</li></ul><p>浮点数的实际值通过指数和尾数来表示。指数用来表示浮点数的数量级，尾数用来表示浮点数的精度。符号位用来表示浮点数的正负。</p><p>浮点数的存储原理基于科学计数法，即一个数可以表示为尾数乘以基数的指数次方。例如，对于单精度浮点数，可以表示为：<br>$$<br>(-1)^{\text{sign}} \times (1 + \text{mantissa}) \times 2^{\text{exponent} - \text{bias}}<br>$$</p><p>其中，sign 是符号位，mantissa 是尾数，exponent 是指数，bias 是偏置值（用于使指数可以表示负数）。这个公式基本上适用于双精度浮点数，只是指数偏置和尾数位数不同。</p><h2 id="三、字符型"><a href="#三、字符型" class="headerlink" title="三、字符型"></a>三、字符型</h2><h3 id="3-1、char"><a href="#3-1、char" class="headerlink" title="3.1、char"></a>3.1、char</h3><p>Java 中的 char 类型使用 Unicode 编码来表示字符。每个字符对应一个</p><p>唯一的 Unicode 码点，可以通过 \u 后跟 4 位十六进制数来表示。</p><h3 id="3-2、转义字符"><a href="#3-2、转义字符" class="headerlink" title="3.2、转义字符"></a>3.2、转义字符</h3><ul><li>\n： 换行符（newline），在输出时表示换行。    </li><li>\t： 制表符（tab），在输出时表示水平制表。    </li><li>\r： 回车符（carriage return），在输出时表示回车。    </li><li>‘： 单引号（single quote），用于表示单引号字符。    </li><li>“： 双引号（double quote），用于表示双引号字符。    </li><li>\： 反斜杠（backslash），用于表示反斜杠字符本身。</li></ul><h3 id="3-3、乱码"><a href="#3-3、乱码" class="headerlink" title="3.3、乱码"></a>3.3、乱码</h3><p>乱码通常是由于文本数据的编码方式与解码方式不匹配或者编码过程中出现了错误所致。<br>所以一定要保持编码与解码一致。</p><h3 id="3-4、char-参与运算"><a href="#3-4、char-参与运算" class="headerlink" title="3.4、char 参与运算"></a>3.4、char 参与运算</h3><p>byte、short、char 混合运算的时候，先各自转换为 int 再做运算。<br>多种数据类型混合运算的时候放，先各自转换为最大的再做运算。   </p><h2 id="四、boolean-类型"><a href="#四、boolean-类型" class="headerlink" title="四、boolean 类型"></a>四、boolean 类型</h2><p>在 Java 中，boolean 的值只有 true、false。（与 C、C++ 有所不同）</p><p><strong>总结：基本数据类型转换规则</strong>   </p><blockquote><p>1、八种基本数据类型除了 boolean 类型之外，都可以互相转换。<br>2、小容量可以自动转换为大容量，容量排序为：byte &lt; short,char &lt; int &lt; long &lt; float &lt; double<br>3、大容量不能自动转换为小容量，必须添加强制类型转换符，才能编译通过，但是运行时可能损失精度。<br>4、当整数型字面量没有超过 byte、short、char 的范围时，可以将其赋值给 byte、short、char 类型的变量。<br>5、byte、short、char 混合运算时，各自先转换为 int 再做运算。<br>6、多种数据类型混合运算的时候放，先各自转换为最大的再做运算。    </p></blockquote><p><strong>注意：</strong></p><blockquote><p>1、long e&#x3D;2147483648; 这个属于一个经典面试题，其错误的原因是 &#x3D; 右边先执行，这个整型字面量会以 int 类型处理，显然超过了 int 范围所以报错。<br>2、理解 byte a&#x3D;10&#x2F;3; 不报错，但是 byte b&#x3D;10; byte c&#x3D;3; a&#x3D;b&#x2F;3; 报错。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
          <category> Java Part_1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java SE基础知识</title>
      <link href="/2024/05/04/Java-SE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/05/04/Java-SE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-SE-基础知识"><a href="#Java-SE-基础知识" class="headerlink" title="Java SE 基础知识"></a>Java SE 基础知识</h1><h2 id="一、Java虚拟机（JVM）"><a href="#一、Java虚拟机（JVM）" class="headerlink" title="一、Java虚拟机（JVM）"></a>一、Java虚拟机（JVM）</h2><p><img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/asserts_JavaSE/202405011249837.png"></p><h2 id="二、Java的加载与执行原理"><a href="#二、Java的加载与执行原理" class="headerlink" title="二、Java的加载与执行原理"></a>二、Java的加载与执行原理</h2><p><img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/asserts_JavaSE/202405011250158.PNG"></p><h2 id="三、JDK、JRE、JVM分别是什么？他们的关系是什么？"><a href="#三、JDK、JRE、JVM分别是什么？他们的关系是什么？" class="headerlink" title="三、JDK、JRE、JVM分别是什么？他们的关系是什么？"></a>三、JDK、JRE、JVM分别是什么？他们的关系是什么？</h2><ol><li><p><strong>JDK（Java Development Kit）：</strong><br>JDK 是 Java 开发工具包，它是 Java 开发者用来开发 Java 应用程序的核心组件。JDK 包括了 Java 编译器（javac）、Java 运行时环境（JRE）、Java 文档生成器（Javadoc）以及其他一些开发工具和库。简而言之，JDK 提供了开发 Java 应用程序所需的所有工具和资源。</p></li><li><p><strong>JRE（Java Runtime Environment）：</strong><br>JRE 是 Java 运行时环境，它是在运行 Java 应用程序时所必需的环境。JRE 包含了 Java 虚拟机（JVM）以及 Java 核心类库和支持文件。当用户想要运行一个已编译的 Java 应用程序时，他们需要安装 JRE。JRE 提供了 Java 应用程序的运行环境，但不包含开发工具。</p></li><li><p><strong>JVM（Java Virtual Machine）：</strong><br>JVM 是 Java 虚拟机，它是 Java 程序的运行环境。JVM 负责在实际的硬件平台上执行 Java 字节码（即编译后的 Java 代码）。JVM 负责加载字节码、解释执行或即时编译字节码为本地机器代码，并管理内存、执行垃圾回收等任务。JVM 的存在使得 Java 能够实现“一次编写，到处运行”的特性。</p><img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/asserts_JavaSE/202405011250370.png"  height="300" width="300"></li></ol><h2 id="四、class和public-class的区别"><a href="#四、class和public-class的区别" class="headerlink" title="四、class和public class的区别"></a>四、class和public class的区别</h2><ol><li>一个 Java 源文件可以定义多个 class。</li><li>编译之后，一个 class 就会对应生成一个 class 字节码文件。</li><li>如果一个类是 public，类名必须要和源文件名保持一致。</li><li>public 类可以没有，如果有的话也只能有一个。</li><li>每个类中都可以编写入口 main 方法。在实际开发中，入口一般只有一个。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;X执行了，这个 Java 源文件名为 X.java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、Java标识符命名规范"><a href="#五、Java标识符命名规范" class="headerlink" title="五、Java标识符命名规范"></a>五、Java标识符命名规范</h2><p>遵循驼峰式命名方法。   </p><ul><li><strong>类名、接口名：</strong> 首字母大写吗，后面每个单词首字母大写。 <code>StudentService</code>    </li><li><strong>变量名、方法名：</strong> 首字母小写，后面每个单词首字母大写。 <code>productPrice</code>    </li><li><strong>常量名：</strong> 全部大写，每个单词之间采用”_”分隔。 <code>LOGIN_SUCCESS</code>    </li><li><strong>包名：</strong> 全部小写。 <code>com.camellia.javase.extends</code></li></ul><h2 id="六、Java中的加号运算符"><a href="#六、Java中的加号运算符" class="headerlink" title="六、Java中的加号运算符"></a>六、Java中的加号运算符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlusTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> b=<span class="number">20</span>;</span><br><span class="line">        String str=<span class="string">&quot;10&quot;</span>;</span><br><span class="line">        <span class="comment">// 字符串拼接</span></span><br><span class="line">        System.out.println(str + b); <span class="comment">// 1020;</span></span><br><span class="line">        </span><br><span class="line">        str=<span class="string">&quot;30&quot;</span>;</span><br><span class="line">        <span class="comment">// 当一个表达式中出现多个+，若没有（），遵循从左到右。</span></span><br><span class="line">        System.out.println(a + b + str); <span class="comment">// 3030;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加了（）优先级比较高。</span></span><br><span class="line">        System.out.println(a+(b+str)); <span class="comment">// 102030</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、变量的分类"><a href="#七、变量的分类" class="headerlink" title="七、变量的分类"></a>七、变量的分类</h2><ul><li><p><strong>局部变量（Local Variables）：</strong><br>在方法、代码块或构造方法中声明的变量称为局部变量。局部变量只在其声明的范围内可见，超出该范围就无法访问。局部变量的生命周期仅在其声明的代码块、方法或构造方法执行期间。当代码块或方法执行完毕时，局部变量将被销毁。    </p></li><li><p><strong>成员变量（Instance Variables）：</strong><br>在类中声明的变量，但在方法之外，类的任何地方都可以访问，称为成员变量或实例变量。每个对象都有一份成员变量的副本，它们属于对象的状态。成员变量的生命周期与对象的生命周期相同。它们随着对象的创建而创建，随着对象的销毁而销毁。    </p></li><li><p><strong>静态变量（Static Variables）：</strong><br>使用 static 关键字声明的成员变量称为静态变量。静态变量属于类而不是对象，在类加载时初始化，并且所有对象共享同一份静态变量。静态变量的生命周期与类的生命周期相同。它们在类加载时初始化，随着类的卸载而销毁。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 变量可以根据定义/声明的位置来进行分类，可以分为两大类：</span></span><br><span class="line"><span class="comment">        1、局部变量</span></span><br><span class="line"><span class="comment">        2、成员变量</span></span><br><span class="line"><span class="comment">          - 静态变量</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> - 实例变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VarClassify</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 凡是在方法体中定义的变量，一定是局部变量。</span></span><br><span class="line">        <span class="comment">// 局部变量只在当前方法体中有效。</span></span><br><span class="line">        <span class="type">int</span> a=<span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在类中定义的变量叫做成员变量。</span></span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="type">int</span> b=<span class="number">200</span>;</span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> c=<span class="number">300</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><blockquote><p>Java 是一种混合型语言，既有编译阶段也有解释阶段。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
          <category> Java Part_1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
